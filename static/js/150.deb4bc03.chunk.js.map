{"version":3,"file":"static/js/150.deb4bc03.chunk.js","mappings":"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","sources":["webpack://my-react-app/./src/components/Geometry.module.css?9b74","components/Geometry.js"],"sourcesContent":["// extracted by mini-css-extract-plugin\nexport default {\"GameArea\":\"Geometry_GameArea__lLLvX\"};","import React, { useState, useEffect, useCallback } from \"react\";\nimport { Stage, Layer, Line, Circle, Rect, Text } from \"react-konva\";\nimport styles from \"./Geometry.module.css\"; // Ensure this path matches your CSS module file\n\nfunction Geometry({ text }) {\n  const [originalPoints, setOriginalPoints] = useState([]);\n  const [scaledPoints, setScaledPoints] = useState([]);\n  const [stageSize, setStageSize] = useState({ width: 0, height: 0 });\n  const [verticesVisible, setVerticesVisible] = useState(true); // New state for vertex visibility\n  const [dragStartPos, setDragStartPos] = useState({ x: 0, y: 0 });\n  const [options, setOptions] = useState({ angles: \"no\" }); // Default option\n  const [shapeTypes, setShapeTypes] = useState([]); // 0 for polygon, 1 for circle\n  const [nominalSize, setNominalSize] = useState({ width: 1000, height: 1000 });\n\n  // Modify this function to capture the starting drag position\n  const handlePolygonDragStart = (e) => {\n    setVerticesVisible(false); // Hide vertices\n    setDragStartPos({ x: e.target.x(), y: e.target.y() }); // Capture start position\n  };\n\n  // Function to handle vertex removal\n  const handleVertexDoubleClick = (polygonIndex, pointIndex) => {\n    setOriginalPoints((prev) => {\n      // Clone to avoid direct state mutation\n      const newPoints = [...prev];\n\n      // Ensure polygon has more than 3 vertices before removing one\n      if (newPoints[polygonIndex].length >= 1) {\n        newPoints[polygonIndex] = [\n          ...newPoints[polygonIndex].slice(0, pointIndex),\n          ...newPoints[polygonIndex].slice(pointIndex + 1),\n        ];\n\n        scalePointsToFitStage(newPoints);\n      }\n\n      return newPoints;\n    });\n  };\n\n  const handlePolygonDragEnd = (e, polygonIndex) => {\n    // Calculate the displacement in scaled coordinates\n    const scaleX = stageSize.width / nominalSize.width;\n    const scaleY = stageSize.height / nominalSize.height;\n    const displacement = {\n      x: (e.target.x() - dragStartPos.x) / scaleX,\n      y: (e.target.y() - dragStartPos.y) / scaleY,\n    };\n\n    // Apply the displacement to the original points\n    const updatedOriginalPoints = originalPoints.map((polygon, idx) =>\n      idx === polygonIndex\n        ? polygon.map((point) => ({\n            x: point.x + displacement.x,\n            y: point.y + displacement.y,\n          }))\n        : polygon\n    );\n\n    setOriginalPoints(updatedOriginalPoints);\n\n    // Recalculate scaled points from updated original points\n    scalePointsToFitStage(updatedOriginalPoints);\n\n    setVerticesVisible(true); // Make vertices visible again\n\n    // Reset the position of the dragged shape to negate Konva's internal drag positioning\n    e.target.position({\n      x: dragStartPos.x,\n      y: dragStartPos.y,\n    });\n    e.target.getLayer().batchDraw(); // Optimize rendering\n  };\n\n  const scalePointsToFitStage = useCallback(\n    (points) => {\n      const scaleX = stageSize.width / nominalSize.width;\n      const scaleY = stageSize.height / nominalSize.height;\n      const scaled = points.map((polygon) =>\n        polygon.map((point) => ({\n          x: point.x * scaleX,\n          y: point.y * scaleY,\n        }))\n      );\n      setScaledPoints(scaled);\n    },\n    [stageSize, nominalSize]\n  );\n\n  useEffect(() => {\n    scalePointsToFitStage(originalPoints);\n  }, [stageSize, originalPoints, scalePointsToFitStage]);\n\n  function parseShapes(text) {\n    const lines = text.split(\"\\n\");\n    let options = { angles: \"no\" }; // Default option\n    let shapes = []; // Stores both polygons and circles as arrays of points\n    let shapeTypes = []; // 0 for polygon, 1 for circle\n\n    lines.forEach((line) => {\n      if (line.startsWith(\"OPTIONS:\")) {\n        // Parse options as before\n        line\n          .substring(\"OPTIONS:\".length)\n          .split(\",\")\n          .forEach((option) => {\n            const [key, value] = option.split(\"=\");\n            options[key] = value;\n          });\n      } else if (line.includes(\"[\")) {\n        // Circle\n        const cpoints = line\n          .match(/\\[(.*?)\\]/g)\n          .map((point) => point.replace(/\\[|\\]/g, \"\").split(\",\").map(Number));\n        shapes.push([\n          { x: cpoints[0][0], y: cpoints[0][1] },\n          { x: cpoints[1][0], y: cpoints[1][1] },\n        ]); // Store as two points\n        shapeTypes.push(1); // Mark as circle\n      } else {\n        // Polygon\n        const ppoints = line.match(/\\((.*?)\\)/g)?.map((ppoint) => {\n          const [x, y] = ppoint.replace(/\\(|\\)/g, \"\").split(\",\").map(Number);\n          return { x, y };\n        });\n        if (ppoints) {\n          shapes.push(ppoints); // Store polygon points normally\n          shapeTypes.push(0); // Mark as polygon\n        }\n      }\n    });\n\n    return { options, points: shapes, shapeTypes };\n  }\n\n  useEffect(() => {\n    const { options: parsedOptions, points, shapeTypes } = parseShapes(text);\n    setOptions(parsedOptions);\n    setOriginalPoints(points);\n    setShapeTypes(shapeTypes);\n    updateStageSize(); // This triggers scaling of points\n    window.addEventListener(\"resize\", updateStageSize);\n    return () => window.removeEventListener(\"resize\", updateStageSize);\n  }, [text]);\n\n  function updateStageSize() {\n    const vw = window.innerWidth * 0.9;\n    const vh = window.innerHeight * 0.9 - 100;\n    const nominalHeight = 1000; // Fixed nominal height\n    const nominalWidth = (vw / vh) * nominalHeight; // Dynamic nominal width based on aspect ratio\n    setStageSize({ width: vw, height: vh });\n    setNominalSize({ width: nominalWidth, height: nominalHeight });\n  }\n\n  // Example handler for right-click events on shapes\n  const handleShapeRightClick = (event, shapeIndex) => {\n    event.evt.preventDefault(); // Prevent default context menu\n\n    setOriginalPoints((prevShapes) => {\n      // Access the shape directly using shapeIndex\n      const shapeToDuplicate = prevShapes[shapeIndex];\n      if (!Array.isArray(shapeToDuplicate)) {\n        console.error(\"Expected an array of points, got:\", shapeToDuplicate);\n        return prevShapes; // Return unchanged if unexpected structure\n      }\n\n      // Clone and offset the shape\n      const newShape = shapeToDuplicate.map((point) => ({\n        x: point.x + 20, // Apply offset\n        y: point.y + 20,\n      }));\n\n      // Return new array with the duplicated shape added\n      return [...prevShapes, newShape];\n    });\n\n    // Remember to also update shapeTypes state if necessary\n    setShapeTypes((prevTypes) => [...prevTypes, prevTypes[shapeIndex]]);\n  };\n\n  // Utility function to calculate distance from a point to a line segment\n  function distanceFromPointToLineSegment(px, py, x1, y1, x2, y2) {\n    let lineLength = Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);\n    if (lineLength === 0) return Math.sqrt((px - x1) ** 2 + (py - y1) ** 2);\n    let t = ((px - x1) * (x2 - x1) + (py - y1) * (y2 - y1)) / lineLength ** 2;\n    t = Math.max(0, Math.min(1, t));\n    let lx = x1 + t * (x2 - x1);\n    let ly = y1 + t * (y2 - y1);\n    return Math.sqrt((px - lx) ** 2 + (py - ly) ** 2);\n  }\n\n  const handleLineDoubleClick = (e, polygonIndex) => {\n    const stage = e.target.getStage();\n    const pointerPosition = stage.getPointerPosition();\n    const scaleX = stageSize.width / nominalSize.width;\n    const scaleY = stageSize.height / nominalSize.height;\n    const clickX = pointerPosition.x / scaleX;\n    const clickY = pointerPosition.y / scaleY;\n\n    const polygon = originalPoints[polygonIndex];\n    let closestSegmentIndex = 0;\n    let minDistance = Infinity;\n\n    for (let i = 0; i < polygon.length; i++) {\n      const nextIndex = (i + 1) % polygon.length;\n      const distance = distanceFromPointToLineSegment(\n        clickX,\n        clickY,\n        polygon[i].x,\n        polygon[i].y,\n        polygon[nextIndex].x,\n        polygon[nextIndex].y\n      );\n\n      if (distance < minDistance) {\n        minDistance = distance;\n        closestSegmentIndex = i;\n      }\n    }\n\n    // Insert the new point after the closest segment's start point\n    const newPoint = { x: clickX, y: clickY };\n    const updatedPolygon = [\n      ...polygon.slice(0, closestSegmentIndex + 1),\n      newPoint,\n      ...polygon.slice(closestSegmentIndex + 1),\n    ];\n\n    const updatedOriginalPoints = [\n      ...originalPoints.slice(0, polygonIndex),\n      updatedPolygon,\n      ...originalPoints.slice(polygonIndex + 1),\n    ];\n\n    setOriginalPoints(updatedOriginalPoints);\n    scalePointsToFitStage(updatedOriginalPoints);\n  };\n\n  function findSnappingPoint(endX, endY, polygonIndex, excludedPointIndex) {\n    const threshold = 10; // Snapping threshold in pixels\n    for (let i = 0; i < scaledPoints.length; i++) {\n      for (let j = 0; j < scaledPoints[i].length; j++) {\n        if (i === polygonIndex && j === excludedPointIndex) continue; // Skip the point being dragged\n        const point = scaledPoints[i][j];\n        if (\n          Math.abs(point.x - endX) < threshold &&\n          Math.abs(point.y - endY) < threshold\n        ) {\n          return point;\n        }\n      }\n    }\n    return null; // No snapping point found\n  }\n\n  const handleDragEnd = (e, polygonIndex, pointIndex) => {\n    const endX = e.target.x();\n    const endY = e.target.y();\n    const snappedPoint = findSnappingPoint(\n      endX,\n      endY,\n      polygonIndex,\n      pointIndex\n    );\n\n    if (snappedPoint) {\n      // Calculate the original coordinates for the snapped point\n      const originalSnappedX =\n        (snappedPoint.x / stageSize.width) * nominalSize.width;\n      const originalSnappedY =\n        (snappedPoint.y / stageSize.height) * nominalSize.height;\n\n      // Update the original points with the new snapped coordinates\n      const updatedOriginalPoints = originalPoints.map((polygon, idx) => {\n        if (idx === polygonIndex) {\n          return polygon.map((point, idx) => {\n            if (idx === pointIndex) {\n              return { x: originalSnappedX, y: originalSnappedY };\n            }\n            return point;\n          });\n        }\n        return polygon;\n      });\n      setOriginalPoints(updatedOriginalPoints);\n\n      // Scale the updated original points to update the scaled points\n      const updatedScaledPoints = updatedOriginalPoints.map((polygon) =>\n        polygon.map((point) => ({\n          x: (point.x / nominalSize.width) * stageSize.width,\n          y: (point.y / nominalSize.height) * stageSize.height,\n        }))\n      );\n      setScaledPoints(updatedScaledPoints);\n\n      // Reset the dragged element to its new position\n      e.target.position({\n        x: snappedPoint.x,\n        y: snappedPoint.y,\n      });\n    } else {\n      // No snap, so revert to the last known good position\n      const lastKnownGoodPosition = scaledPoints[polygonIndex][pointIndex];\n      e.target.position({\n        x: lastKnownGoodPosition.x,\n        y: lastKnownGoodPosition.y,\n      });\n    }\n    e.target.getLayer().batchDraw(); // Optimize rendering\n  };\n\n  const handleDragMove = (e, polygonIndex, pointIndex) => {\n    const scaleX = stageSize.width / nominalSize.width;\n    const scaleY = stageSize.height / nominalSize.height;\n    // Calculate proposed new positions before applying them\n    const proposedNewX = e.target.x() / scaleX;\n    const proposedNewY = e.target.y() / scaleY;\n\n    // Check if the proposed new positions fall outside the nominal area\n    if (\n      proposedNewX < 20 ||\n      proposedNewX > nominalSize.width - 20 ||\n      proposedNewY < 0 ||\n      proposedNewY > nominalSize.height - 20\n    ) {\n      // If outside the bounds, reject the update and return to leave the point as is\n      return;\n    }\n\n    // If within bounds, proceed to update the points\n    const newScaledPoints = scaledPoints.map((polygon, pIdx) => {\n      if (pIdx === polygonIndex) {\n        return polygon.map((point, ptIdx) => {\n          if (ptIdx === pointIndex) {\n            return { x: e.target.x(), y: e.target.y() };\n          }\n          return point;\n        });\n      }\n      return polygon;\n    });\n    setScaledPoints(newScaledPoints);\n\n    // Update original points to reflect the change for future resizes\n    const newOriginalPoints = newScaledPoints.map((polygon) =>\n      polygon.map((point) => ({\n        x: (point.x * nominalSize.width) / stageSize.width,\n        y: (point.y * nominalSize.height) / stageSize.height,\n      }))\n    );\n    setOriginalPoints(newOriginalPoints);\n  };\n\n  function vectorMagnitude(v) {\n    return Math.sqrt(v.x * v.x + v.y * v.y);\n  }\n\n  // Utility function to calculate the dot product of two vectors\n  function dotProduct(u, v) {\n    return u.x * v.x + u.y * v.y;\n  }\n\n  // Function to calculate the angle at a vertex given three points: prev, curr, and next\n  function calculateAngle(prev, curr, next) {\n    const u = { x: prev.x - curr.x, y: prev.y - curr.y };\n    const v = { x: next.x - curr.x, y: next.y - curr.y };\n\n    const dot = dotProduct(u, v);\n    const magU = vectorMagnitude(u);\n    const magV = vectorMagnitude(v);\n    const cosTheta = dot / (magU * magV);\n\n    // Convert to degrees for readability\n    return Math.acos(cosTheta) * (180 / Math.PI);\n  }\n\n  return (\n    <>\n      <div className={styles.GameArea}>\n        <Stage\n          width={stageSize.width}\n          height={stageSize.height}\n          className={styles.GameArea}\n        >\n          <Layer>\n            {/* Draw a rectangle that matches the size of the Stage to act as a border */}\n            <Rect\n              x={0}\n              y={0}\n              width={stageSize.width}\n              height={stageSize.height}\n              stroke=\"black\" // Color of the border\n              strokeWidth={4} // Thickness of the border\n            />\n            {scaledPoints.map((polygon, polygonIndex) => (\n              <React.Fragment key={polygonIndex}>\n                {shapeTypes[polygonIndex] === 0 && (\n                  // Render polygon logic\n                  <Line\n                    points={polygon.flatMap((p) => [p.x, p.y])}\n                    closed={true}\n                    stroke=\"black\"\n                    onDblClick={(e) => handleLineDoubleClick(e, polygonIndex)}\n                    onContextMenu={(e) =>\n                      handleShapeRightClick(e, polygonIndex)\n                    }\n                    draggable\n                    onDragStart={handlePolygonDragStart}\n                    onDragEnd={(e) => handlePolygonDragEnd(e, polygonIndex)}\n                  />\n                )}\n                {shapeTypes[polygonIndex] === 1 && (\n                  // Render circle\n                  <Circle\n                    x={polygon[0].x} // Center x\n                    y={polygon[0].y} // Center y\n                    radius={Math.sqrt(\n                      Math.pow(polygon[1].x - polygon[0].x, 2) +\n                        Math.pow(polygon[1].y - polygon[0].y, 2)\n                    )}\n                    stroke=\"black\"\n                    strokeWidth={2}\n                    onContextMenu={(e) =>\n                      handleShapeRightClick(e, polygonIndex)\n                    }\n                    draggable\n                    onDragStart={handlePolygonDragStart}\n                    onDragEnd={(e) => handlePolygonDragEnd(e, polygonIndex)}\n                  />\n                )}\n                {polygon.map((point, pointIndex) => (\n                  <Circle\n                    key={pointIndex}\n                    x={point.x}\n                    y={point.y}\n                    radius={5}\n                    fill=\"red\"\n                    draggable={verticesVisible}\n                    visible={verticesVisible}\n                    onDragMove={(e) =>\n                      handleDragMove(e, polygonIndex, pointIndex)\n                    }\n                    onDragEnd={(e) =>\n                      handleDragEnd(e, polygonIndex, pointIndex)\n                    }\n                    onDblClick={() =>\n                      handleVertexDoubleClick(polygonIndex, pointIndex)\n                    }\n                  />\n                ))}\n                {polygon.length > 2 &&\n                  options.angles === \"yes\" &&\n                  polygon.map((point, pointIndex) => {\n                    const prev =\n                      polygon[\n                        (pointIndex - 1 + polygon.length) % polygon.length\n                      ];\n                    const curr = point;\n                    const next = polygon[(pointIndex + 1) % polygon.length];\n\n                    const angle = calculateAngle(prev, curr, next);\n                    const angleText = angle.toFixed(1) + \"°\";\n\n                    // Implementing the bisector method for label positioning\n                    if (\n                      Math.abs(angle) > 0.5 &&\n                      Math.abs(angle - 180.0) > 0.5\n                    ) {\n                      // Normalize function to calculate unit vectors\n                      const normalize = (vector) => {\n                        const length = Math.sqrt(\n                          vector.x * vector.x + vector.y * vector.y\n                        );\n                        return { x: vector.x / length, y: vector.y / length };\n                      };\n\n                      // Calculate vectors to previous and next points\n                      const vectorToPrev = normalize({\n                        x: prev.x - curr.x,\n                        y: prev.y - curr.y,\n                      });\n                      const vectorToNext = normalize({\n                        x: next.x - curr.x,\n                        y: next.y - curr.y,\n                      });\n\n                      // Bisector direction\n                      const bisector = normalize({\n                        x: vectorToPrev.x + vectorToNext.x,\n                        y: vectorToPrev.y + vectorToNext.y,\n                      });\n\n                      let nudgeDistance = stageSize.width / 45; // Adjust based on your requirements\n\n                      let rotationAngle =\n                        Math.atan2(bisector.y, bisector.x) * (180 / Math.PI);\n\n                      if (rotationAngle < -90 || rotationAngle > 90) {\n                        rotationAngle += 180; // Flip text upside down if it's facing left\n                        nudgeDistance *= 3;\n                      }\n\n                      return (\n                        <React.Fragment key={pointIndex}>\n                          <Text\n                            x={curr.x + bisector.x * nudgeDistance}\n                            y={curr.y + bisector.y * nudgeDistance}\n                            text={angleText}\n                            fontSize={12}\n                            fill=\"black\"\n                            visible={verticesVisible}\n                            rotation={rotationAngle}\n                          />\n                        </React.Fragment>\n                      );\n                    } else {\n                      return null;\n                    }\n                  })}\n              </React.Fragment>\n            ))}\n          </Layer>\n          <Layer>\n            {scaledPoints.map((polygon, polygonIndex) => (\n              <React.Fragment key={`v${polygonIndex}`}>\n                {polygon.map((point, pointIndex) => (\n                  <Circle\n                    key={pointIndex}\n                    x={point.x}\n                    y={point.y}\n                    radius={5}\n                    fill=\"red\"\n                    draggable={verticesVisible}\n                    visible={verticesVisible}\n                    onDragMove={(e) =>\n                      handleDragMove(e, polygonIndex, pointIndex)\n                    }\n                    onDragEnd={(e) =>\n                      handleDragEnd(e, polygonIndex, pointIndex)\n                    }\n                    onDblClick={() =>\n                      handleVertexDoubleClick(polygonIndex, pointIndex)\n                    }\n                  />\n                ))}\n              </React.Fragment>\n            ))}\n          </Layer>\n        </Stage>\n      </div>\n    </>\n  );\n}\n\nexport default Geometry;\n"],"names":["_ref","text","originalPoints","setOriginalPoints","useState","scaledPoints","setScaledPoints","stageSize","setStageSize","width","height","verticesVisible","setVerticesVisible","dragStartPos","setDragStartPos","x","y","options","setOptions","angles","shapeTypes","setShapeTypes","nominalSize","setNominalSize","handlePolygonDragStart","e","target","handleVertexDoubleClick","polygonIndex","pointIndex","prev","newPoints","length","slice","scalePointsToFitStage","handlePolygonDragEnd","scaleX","scaleY","displacement","updatedOriginalPoints","map","polygon","idx","point","position","getLayer","batchDraw","useCallback","points","scaled","updateStageSize","vw","window","innerWidth","vh","innerHeight","nominalWidth","useEffect","parsedOptions","lines","split","shapes","forEach","line","startsWith","substring","option","key","value","includes","cpoints","match","replace","Number","push","_line$match","ppoints","ppoint","parseShapes","addEventListener","removeEventListener","handleShapeRightClick","event","shapeIndex","evt","preventDefault","prevShapes","shapeToDuplicate","Array","isArray","console","error","newShape","prevTypes","distanceFromPointToLineSegment","px","py","x1","y1","x2","y2","lineLength","Math","sqrt","t","max","min","lx","ly","handleDragEnd","snappedPoint","endX","endY","excludedPointIndex","i","j","abs","findSnappingPoint","originalSnappedX","originalSnappedY","updatedScaledPoints","lastKnownGoodPosition","handleDragMove","proposedNewX","proposedNewY","newScaledPoints","pIdx","ptIdx","newOriginalPoints","vectorMagnitude","v","_jsx","_Fragment","children","className","styles","_jsxs","Stage","Layer","Rect","stroke","strokeWidth","React","Line","flatMap","p","closed","onDblClick","handleLineDoubleClick","pointerPosition","getStage","getPointerPosition","clickX","clickY","closestSegmentIndex","minDistance","Infinity","nextIndex","distance","newPoint","updatedPolygon","onContextMenu","draggable","onDragStart","onDragEnd","Circle","radius","pow","fill","visible","onDragMove","curr","next","angle","u","cosTheta","dotProduct","acos","PI","calculateAngle","angleText","toFixed","normalize","vector","vectorToPrev","vectorToNext","bisector","nudgeDistance","rotationAngle","atan2","Text","fontSize","rotation","concat"],"sourceRoot":""}