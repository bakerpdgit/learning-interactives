{"version":3,"file":"static/js/521.7b0a76c1.chunk.js","mappings":"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","sources":["components/MathComponent.js","components/Tarsia.js"],"sourcesContent":["import { InlineMath } from \"react-katex\";\r\n\r\nfunction parseAndRenderMath(text) {\r\n  // Split the text based on $$ delimiters\r\n  const segments = text.split(\"$$\");\r\n  const elements = [];\r\n\r\n  segments.forEach((segment, index) => {\r\n    if (index % 2 === 1) {\r\n      // Odd-indexed segments are LaTeX (since they are enclosed between $$ delimiters)\r\n      elements.push(<InlineMath key={`MCIM${index}`} math={segment} />);\r\n    } else {\r\n      elements.push(<span key={`MCSP${index}`}>{segment}</span>);\r\n    }\r\n  });\r\n\r\n  return elements;\r\n}\r\n\r\nconst renderWithNewLines = (text) => {\r\n  return text.replace(/\\\\n/g, \"\\n\");\r\n};\r\n\r\nfunction MathComponent({ text, renderNewLines = false }) {\r\n  if (renderNewLines) {\r\n    text = renderWithNewLines(text);\r\n  }\r\n\r\n  return (\r\n    <div\r\n      style={{\r\n        whiteSpace:\r\n          text.includes(\"\\n\") && renderNewLines ? \"pre-wrap\" : \"normal\",\r\n        marginTop: text.includes(\"$$\") ? \"0.5em\" : \"0\",\r\n      }}\r\n    >\r\n      {parseAndRenderMath(text)}\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default MathComponent;\r\n","import React, {\r\n  useState,\r\n  useImperativeHandle,\r\n  forwardRef,\r\n  useRef,\r\n} from \"react\";\r\nimport \"./Tarsia.css\";\r\nimport MathComponent from \"./MathComponent.js\";\r\n\r\nconst SquareComponent = forwardRef((props, ref) => {\r\n  const { lb1, lb2, lb3, lb4, isSelected, onSelect } = props;\r\n  // eslint-disable-next-line\r\n  const [labels, setLabels] = useState([lb1, lb2, lb3, lb4]);\r\n\r\n  useImperativeHandle(ref, () => ({\r\n    getLabels: () => labels,\r\n    setLabels: (newLabels) => setLabels(newLabels),\r\n    rotateLabels: () => {\r\n      setLabels((prevLabels) => [prevLabels[3], ...prevLabels.slice(0, 3)]);\r\n    },\r\n  }));\r\n\r\n  return (\r\n    <div\r\n      className={`square ${isSelected ? \"selected\" : \"\"}`}\r\n      onClick={onSelect}\r\n    >\r\n      <div className=\"label top\">\r\n        {\" \"}\r\n        <MathComponent text={labels[0]} renderNewLines={true} />\r\n      </div>\r\n      <div className=\"label right\">\r\n        {\" \"}\r\n        <MathComponent text={labels[1]} renderNewLines={true} />\r\n      </div>\r\n      <div className=\"label bottom\">\r\n        {\" \"}\r\n        <MathComponent text={labels[2]} renderNewLines={true} />\r\n      </div>\r\n      <div className=\"label left\">\r\n        {\" \"}\r\n        <MathComponent text={labels[3]} renderNewLines={true} />\r\n      </div>\r\n      <button\r\n        className=\"rotate-button\"\r\n        style={{ fontSize: \"1.5em\" }}\r\n        onClick={(event) => {\r\n          event.stopPropagation();\r\n          setLabels((prev) => [prev[3], ...prev.slice(0, 3)]);\r\n        }}\r\n      >\r\n        ðŸ”„\r\n      </button>\r\n    </div>\r\n  );\r\n});\r\n\r\nfunction findAdjacent(squareIndex, labelIndex, gridDimension) {\r\n  const row = Math.floor(squareIndex / gridDimension);\r\n  const col = squareIndex % gridDimension;\r\n\r\n  let adjacentRow = row;\r\n  let adjacentCol = col;\r\n  let adjacentLabelIndex;\r\n\r\n  switch (labelIndex) {\r\n    case 0: // Top\r\n      adjacentRow = row - 1;\r\n      adjacentLabelIndex = 2; // Bottom label of the square above\r\n      break;\r\n    case 1: // Right\r\n      adjacentCol = col + 1;\r\n      adjacentLabelIndex = 3; // Left label of the square on the right\r\n      break;\r\n    case 2: // Bottom\r\n      adjacentRow = row + 1;\r\n      adjacentLabelIndex = 0; // Top label of the square below\r\n      break;\r\n    case 3: // Left\r\n      adjacentCol = col - 1;\r\n      adjacentLabelIndex = 1; // Right label of the square on the left\r\n      break;\r\n    default:\r\n      return null;\r\n  }\r\n\r\n  if (\r\n    adjacentRow >= 0 &&\r\n    adjacentRow < gridDimension &&\r\n    adjacentCol >= 0 &&\r\n    adjacentCol < gridDimension\r\n  ) {\r\n    const adjacentSquareIndex = adjacentRow * gridDimension + adjacentCol;\r\n    return { squareIndex: adjacentSquareIndex, labelIndex: adjacentLabelIndex };\r\n  } else {\r\n    return null; // Indicates the label is facing outwards\r\n  }\r\n}\r\n\r\nfunction checkSolution(squares, originalPairs, gridDimension) {\r\n  for (let squareIndex = 0; squareIndex < squares.length; squareIndex++) {\r\n    const square = squares[squareIndex];\r\n\r\n    for (let labelIndex = 0; labelIndex < 4; labelIndex++) {\r\n      const label = square.labels[labelIndex];\r\n\r\n      // Skip empty labels\r\n      if (label === \"\") continue;\r\n\r\n      // Find the adjacent square and label index\r\n      const adjacent = findAdjacent(squareIndex, labelIndex, gridDimension);\r\n\r\n      // If there's no adjacent square (label is facing outwards), puzzle can't be correct\r\n      if (adjacent === null) return false;\r\n\r\n      // Get the label from the adjacent square\r\n      const adjacentLabel =\r\n        squares[adjacent.squareIndex].labels[adjacent.labelIndex];\r\n\r\n      // If the adjacent label is empty, puzzle can't be correct\r\n      if (adjacentLabel === \"\") return false;\r\n\r\n      // Check if the pair exists in the original pairs list\r\n      const pair = `${label}:${adjacentLabel}`;\r\n      const reversedPair = `${adjacentLabel}:${label}`;\r\n\r\n      if (\r\n        !originalPairs.includes(pair) &&\r\n        !originalPairs.includes(reversedPair)\r\n      ) {\r\n        return false;\r\n      }\r\n    }\r\n  }\r\n\r\n  // If we've made it through all the checks, the puzzle is correct\r\n  return true;\r\n}\r\n\r\nconst SquareGrid = ({ components, originalPairs, gridDimension }) => {\r\n  const [selected, setSelected] = useState(null);\r\n  const [firstSelected, setFirstSelected] = useState(null); // First selected square for swapping\r\n  const squareRefs = useRef([]);\r\n  const [message, setMessage] = useState(null);\r\n  const [fontSize, setFontSize] = useState(1); // Default font size\r\n  const [isCorrect, setIsCorrect] = useState(false);\r\n\r\n  const increaseFontSize = () => setFontSize((prevSize) => prevSize + 0.1);\r\n  const decreaseFontSize = () =>\r\n    setFontSize((prevSize) => Math.max(0.4, prevSize - 0.1));\r\n\r\n  const handleCheckSolution = () => {\r\n    const result = checkPuzzle();\r\n    if (result) {\r\n      setIsCorrect(true);\r\n      setMessage(\"Well Done!\");\r\n    } else {\r\n      setIsCorrect(false);\r\n      setMessage(\"Not Yet!\");\r\n    }\r\n\r\n    // Clear the message after 2 seconds\r\n    setTimeout(() => setMessage(null), 2000);\r\n  };\r\n\r\n  const checkPuzzle = () => {\r\n    const allSquares = squareRefs.current.map((ref) => ({\r\n      labels: ref.getLabels(),\r\n    }));\r\n    return checkSolution(allSquares, originalPairs, gridDimension);\r\n  };\r\n\r\n  const handleSelect = (index) => {\r\n    if (firstSelected !== null) {\r\n      // Swap labels between firstSelected and currently selected square\r\n      const firstLabels = squareRefs.current[firstSelected].getLabels();\r\n      const secondLabels = squareRefs.current[index].getLabels();\r\n      squareRefs.current[firstSelected].setLabels(secondLabels);\r\n      squareRefs.current[index].setLabels(firstLabels);\r\n\r\n      // Reset firstSelected and selected\r\n      setFirstSelected(null);\r\n      setSelected(null);\r\n\r\n      checkPuzzle();\r\n    } else {\r\n      setFirstSelected(index);\r\n      setSelected(index);\r\n    }\r\n  };\r\n\r\n  return (\r\n    <>\r\n      <div\r\n        style={{ fontSize: `${fontSize}em` }}\r\n        className={`grid-container ${\r\n          gridDimension === 3 ? \"three-by-three\" : \"four-by-four\"\r\n        }`}\r\n      >\r\n        {components.map((props, index) => (\r\n          <div key={index} className=\"grid-item\">\r\n            <SquareComponent\r\n              ref={(el) => (squareRefs.current[index] = el)}\r\n              {...props}\r\n              isSelected={selected === index}\r\n              onSelect={() => handleSelect(index)}\r\n              checkPuzzle={checkPuzzle}\r\n            />\r\n          </div>\r\n        ))}\r\n      </div>\r\n      {message && (\r\n        <div className={`message ${isCorrect ? \"isCorrect\" : \"isIncorrect\"}`}>\r\n          {message}\r\n        </div>\r\n      )}\r\n      <span>\r\n        <button onClick={handleCheckSolution}>Check Solution</button>\r\n        <button onClick={increaseFontSize}>+</button>\r\n        <button onClick={decreaseFontSize}>-</button>\r\n      </span>\r\n    </>\r\n  );\r\n};\r\n\r\nconst GameArea = ({ text }) => {\r\n  let lines = text.split(\"\\n\");\r\n  const originalPairs = lines.map((line) => line.replace(\"\\n\", \"\"));\r\n  // Shuffle and swap function\r\n  function shuffleArray(array) {\r\n    for (let i = array.length - 1; i > 0; i--) {\r\n      const j = Math.floor(Math.random() * (i + 1));\r\n      [array[i], array[j]] = [array[j], array[i]];\r\n    }\r\n    return array;\r\n  }\r\n\r\n  // Function to rotate labels in a grid object\r\n  const rotateLabels = (gridObj) => {\r\n    const keys = [\"lb1\", \"lb2\", \"lb3\", \"lb4\"];\r\n    const numRotations = Math.floor(Math.random() * 4); // Random number between 0 and 3\r\n\r\n    for (let i = 0; i < numRotations; i++) {\r\n      const temp = gridObj[keys[3]];\r\n      for (let j = 3; j > 0; j--) {\r\n        gridObj[keys[j]] = gridObj[keys[j - 1]];\r\n      }\r\n      gridObj[keys[0]] = temp;\r\n    }\r\n\r\n    return gridObj;\r\n  };\r\n\r\n  // Randomly swap questions and answers and shuffle the order\r\n  lines = shuffleArray(\r\n    lines.map((line) => {\r\n      const [q, a] = line.split(\":\");\r\n      return Math.random() > 0.5 ? `${a}:${q}` : line;\r\n    })\r\n  );\r\n\r\n  // BUILD PUZZLE: Step 1: Determine Grid Dimension\r\n  const pairsCount = lines.length;\r\n  let gridDimension;\r\n\r\n  if (pairsCount <= 12) {\r\n    gridDimension = 3;\r\n  } else if (pairsCount <= 24) {\r\n    gridDimension = 4;\r\n  } else {\r\n    console.error(\"Too many question-answer pairs!\");\r\n  }\r\n\r\n  // Step 2: Initialize 2D Grid\r\n  const grid = Array.from({ length: gridDimension }, () =>\r\n    Array.from({ length: gridDimension }, () => ({\r\n      lb1: \"\",\r\n      lb2: \"\",\r\n      lb3: \"\",\r\n      lb4: \"\",\r\n    }))\r\n  );\r\n\r\n  // Step 3: Populate Labels\r\n  let counter = 0;\r\n  const qaPairs = lines.map((line) => {\r\n    const [question, answer] = line.split(\":\");\r\n    return { question, answer };\r\n  });\r\n\r\n  for (let row = 0; row < gridDimension; row++) {\r\n    for (let col = 0; col < gridDimension - 1; col++) {\r\n      if (counter < pairsCount) {\r\n        grid[row][col].lb2 = qaPairs[counter].question;\r\n        grid[row][col + 1].lb4 = qaPairs[counter].answer;\r\n        counter++;\r\n      }\r\n    }\r\n    if (row < gridDimension - 1) {\r\n      for (let col = 0; col < gridDimension; col++) {\r\n        if (counter < pairsCount) {\r\n          grid[row][col].lb3 = qaPairs[counter].question;\r\n          grid[row + 1][col].lb1 = qaPairs[counter].answer;\r\n          counter++;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // Step 4: Flatten 2D Grid\r\n  const components = shuffleArray(grid.flat());\r\n\r\n  // Step 5: apply a random number of rotations to each:\r\n  const rotatedComponents = components.map(rotateLabels);\r\n\r\n  // Pass 'components' to SquareGrid\r\n\r\n  return (\r\n    <div className=\"gameArea\">\r\n      <SquareGrid\r\n        components={rotatedComponents}\r\n        originalPairs={originalPairs}\r\n        gridDimension={gridDimension}\r\n      />\r\n    </div>\r\n  );\r\n};\r\n\r\nfunction Tarsia({ text }) {\r\n  return (\r\n    <>\r\n      <h1 className=\"interactiveTitle\">Tarsia Puzzle</h1>\r\n      <p className=\"instructions\">\r\n        Get pairs next to each other: use rotate button or click one box then\r\n        the other to swap.\r\n      </p>\r\n      <GameArea text={text} />\r\n    </>\r\n  );\r\n}\r\n\r\nexport default Tarsia;\r\n"],"names":["parseAndRenderMath","text","segments","split","elements","forEach","segment","index","push","_jsx","InlineMath","math","concat","children","_ref","renderNewLines","replace","renderWithNewLines","style","whiteSpace","includes","marginTop","SquareComponent","forwardRef","props","ref","lb1","lb2","lb3","lb4","isSelected","onSelect","labels","setLabels","useState","useImperativeHandle","getLabels","newLabels","rotateLabels","prevLabels","slice","_jsxs","className","onClick","MathComponent","fontSize","event","stopPropagation","prev","findAdjacent","squareIndex","labelIndex","gridDimension","row","Math","floor","col","adjacentLabelIndex","adjacentRow","adjacentCol","SquareGrid","components","originalPairs","selected","setSelected","firstSelected","setFirstSelected","squareRefs","useRef","message","setMessage","setFontSize","isCorrect","setIsCorrect","checkPuzzle","squares","length","square","label","adjacent","adjacentLabel","pair","reversedPair","checkSolution","current","map","_Fragment","el","firstLabels","secondLabels","handleSelect","handleCheckSolution","setTimeout","increaseFontSize","prevSize","decreaseFontSize","max","GameArea","_ref2","lines","line","shuffleArray","array","i","j","random","q","a","pairsCount","console","error","grid","Array","from","counter","qaPairs","question","answer","rotatedComponents","flat","gridObj","keys","numRotations","temp","_ref3"],"sourceRoot":""}