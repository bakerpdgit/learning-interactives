{"version":3,"file":"static/js/209.4386d13e.chunk.js","mappings":"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","sources":["webpack://my-react-app/./src/components/WordSearch.module.css?1ff4","components/WordSearch.js"],"sourcesContent":["// extracted by mini-css-extract-plugin\nexport default {\"GameArea\":\"WordSearch_GameArea__tAV2U\",\"instructions\":\"WordSearch_instructions__cyuSi\",\"RevealButton\":\"WordSearch_RevealButton__sQxtH\",\"Container\":\"WordSearch_Container__jr9bd\",\"WordSearchGrid\":\"WordSearch_WordSearchGrid__aeVss\",\"WordSearchRow\":\"WordSearch_WordSearchRow__ZqvBD\",\"WordSearchCell\":\"WordSearch_WordSearchCell__ohZaY\",\"WordList\":\"WordSearch_WordList__xjQX-\",\"RevealedCell\":\"WordSearch_RevealedCell__7EwFz\",\"SelectedCell\":\"WordSearch_SelectedCell__U1bv+\",\"FoundCell\":\"WordSearch_FoundCell__kpWJP\",\"FoundWord\":\"WordSearch_FoundWord__AOkoD\",\"celebration\":\"WordSearch_celebration__-OI9z\",\"scale\":\"WordSearch_scale__Ods1w\",\"hide\":\"WordSearch_hide__8wt9y\"};","import React, { useState, useEffect } from \"react\";\nimport styles from \"./WordSearch.module.css\";\n\nfunction WordSearch({ text }) {\n  const [gridSize, setGridSize] = useState(12);\n  const [showWords, setShowWords] = useState(false);\n  const [title, setTitle] = useState(\"\");\n  const [words, setWords] = useState([]);\n  const [grid, setGrid] = useState([]);\n  const [revealWords, setRevealWords] = useState(false);\n  const [wordPlacements, setWordPlacements] = useState([]);\n  const [usedCoordinates, setUsedCoordinates] = useState([]);\n  const [selectedLetters, setSelectedLetters] = useState([]);\n  const [foundWords, setFoundWords] = useState([]);\n  const [wordsToFind, setWordsToFind] = useState(words.length);\n  const [failed, setFailed] = useState(false);\n\n  useEffect(() => {\n    const lines = text.split(\"\\n\");\n    const optionsLine = lines[0];\n    const options = optionsLine.slice(8).split(\",\");\n    let simpleMode = false;\n    let sizeChoice = 10;\n    let showChoice = true;\n\n    options.forEach((option) => {\n      const [key, value] = option.split(\"=\");\n      if (key.trim().toLowerCase() === \"size\") {\n        sizeChoice = parseInt(value);\n        setGridSize(sizeChoice);\n      } else if (key.trim().toLowerCase() === \"show\") {\n        showChoice = value.trim().toLowerCase() === \"yes\";\n        setShowWords(showChoice);\n      } else if (key.trim().toLowerCase() === \"simple\") {\n        simpleMode = value.trim().toLowerCase() === \"yes\";\n      }\n    });\n\n    setTitle(lines[1]);\n    const tempWordsList = lines.slice(2).filter((word) => word.trim() !== \"\");\n    const uppercaseWordsList = tempWordsList.map((word) => word.toUpperCase());\n    setWords(uppercaseWordsList);\n    setWordsToFind(uppercaseWordsList.length);\n\n    // Check if any word is longer than the grid size\n    const isAnyWordTooLong = uppercaseWordsList.some(\n      (word) => word.length > sizeChoice\n    );\n\n    if (isAnyWordTooLong || sizeChoice > 20 || sizeChoice < 5) {\n      setFailed(true);\n      return;\n    }\n\n    let attempts = 0;\n    let success = false;\n    while (attempts < 3 && !success) {\n      const { grid, wordPlacements, usedCoordinates } = generateWordSearch(\n        sizeChoice,\n        uppercaseWordsList,\n        simpleMode\n      );\n\n      if (grid.length !== 0) {\n        setGrid(grid);\n        setWordPlacements(wordPlacements);\n        setUsedCoordinates(usedCoordinates);\n        success = true; // Successfully generated the grid\n      } else {\n        attempts++;\n      }\n    }\n\n    if (!success) {\n      setFailed(true);\n    }\n  }, [text, gridSize]);\n\n  const handleReveal = () => {\n    setRevealWords(true);\n  };\n\n  function isPartOfWord(rowIndex, colIndex) {\n    return usedCoordinates.includes(`${rowIndex}-${colIndex}`);\n  }\n\n  const handleCellClick = (rowIndex, colIndex) => {\n    if (revealWords) {\n      return;\n    }\n    const selectedCell = `${rowIndex}-${colIndex}`;\n    const updatedSelectedLetters = [...selectedLetters];\n\n    if (selectedLetters.length === 2) {\n      updatedSelectedLetters.splice(0, 2);\n    }\n\n    updatedSelectedLetters.push(selectedCell);\n    setSelectedLetters(updatedSelectedLetters);\n\n    if (updatedSelectedLetters.length === 2) {\n      checkSelectedWord(updatedSelectedLetters);\n    }\n  };\n\n  const markWordAsFound = (word) => {\n    setFoundWords([...foundWords, word]);\n    setSelectedLetters([]);\n    setWordsToFind((prevCount) => prevCount - 1);\n  };\n\n  const checkSelectedWord = (selectedCells) => {\n    const [startCell, endCell] = selectedCells;\n    const [selectedStartRow, selectedStartCol] = startCell\n      .split(\"-\")\n      .map(Number);\n    const [selectedEndRow, selectedEndCol] = endCell.split(\"-\").map(Number);\n\n    for (const { word, startRow, startCol, direction } of wordPlacements) {\n      const { dx, dy } = direction;\n      const wordLength = word.length;\n\n      if (\n        selectedStartRow === startRow &&\n        selectedStartCol === startCol &&\n        selectedEndRow === startRow + (wordLength - 1) * dy &&\n        selectedEndCol === startCol + (wordLength - 1) * dx\n      ) {\n        markWordAsFound(word);\n        return;\n      }\n    }\n\n    setSelectedLetters([]);\n  };\n\n  function isPartOfFoundWord(rowIndex, colIndex, word) {\n    for (const {\n      word: foundWord,\n      startRow,\n      startCol,\n      direction,\n    } of wordPlacements) {\n      if (foundWord === word) {\n        const { dx, dy } = direction;\n        const wordLength = word.length;\n\n        for (let i = 0; i < wordLength; i++) {\n          if (\n            rowIndex === startRow + i * dy &&\n            colIndex === startCol + i * dx\n          ) {\n            return true;\n          }\n        }\n      }\n    }\n    return false;\n  }\n\n  return failed ? (\n    <>\n      <h1>{title}</h1>\n      <p className={styles.instructions}>\n        Failed to create wordsearch: refresh to try again or change the puzzle\n        to use a different grid size.\n      </p>\n    </>\n  ) : (\n    <>\n      <h1>{title}</h1>\n      <p className={styles.instructions}>\n        Click the first and then last letter of a word to mark it in the grid.\n      </p>\n      {wordsToFind === 0 && words.length > 0 && (\n        <div className={styles.celebration}>😃</div>\n      )}\n      <div className={styles.Container}>\n        <div className={styles.GameArea}>\n          <div\n            className={styles.WordSearchGrid}\n            style={{ gridTemplateColumns: `repeat(${gridSize}, 1fr)` }}\n          >\n            {grid.map((row, rowIndex) => (\n              <div key={rowIndex} className={styles.WordSearchRow}>\n                {row.map((cell, colIndex) => (\n                  <div\n                    key={colIndex}\n                    className={`${styles.WordSearchCell} ${\n                      revealWords && isPartOfWord(rowIndex, colIndex)\n                        ? styles.RevealedCell\n                        : \"\"\n                    } ${\n                      selectedLetters.includes(`${rowIndex}-${colIndex}`)\n                        ? styles.SelectedCell\n                        : \"\"\n                    } ${\n                      foundWords.some((word) =>\n                        isPartOfFoundWord(rowIndex, colIndex, word)\n                      )\n                        ? styles.FoundCell\n                        : \"\"\n                    }`}\n                    onClick={() => handleCellClick(rowIndex, colIndex)}\n                  >\n                    {cell}\n                  </div>\n                ))}\n              </div>\n            ))}\n          </div>\n\n          {!showWords && (\n            <div className={styles.WordList}>\n              <h2>Words to Find:</h2>\n              <ul>\n                <li>{wordsToFind}</li>\n              </ul>\n            </div>\n          )}\n\n          {showWords && (\n            <div className={styles.WordList}>\n              <h2>Words to Find:</h2>\n              <ul>\n                {words.map((word, index) => (\n                  <li\n                    key={index}\n                    className={\n                      foundWords.includes(word) ? styles.FoundWord : \"\"\n                    }\n                  >\n                    {word}\n                  </li>\n                ))}\n              </ul>\n            </div>\n          )}\n        </div>\n        <button onClick={handleReveal} className={styles.RevealButton}>\n          Reveal\n        </button>\n      </div>\n    </>\n  );\n}\nfunction generateWordSearch(size, words, simpleMode) {\n  const directions = simpleMode\n    ? [\n        { dx: 1, dy: 0 }, // Right\n        { dx: 0, dy: 1 }, // Down\n        { dx: 1, dy: 1 }, // Diagonal down-right\n        { dx: -1, dy: 1 }, // Diagonal up-right\n      ]\n    : [\n        { dx: 1, dy: 0 }, // Right\n        { dx: -1, dy: 0 }, // Left\n        { dx: 0, dy: 1 }, // Down\n        { dx: 0, dy: -1 }, // Up\n        { dx: 1, dy: 1 }, // Diagonal down-right\n        { dx: -1, dy: 1 }, // Diagonal down-left\n        { dx: 1, dy: -1 }, // Diagonal up-right\n        { dx: -1, dy: -1 }, // Diagonal up-left\n      ];\n\n  let grid = Array.from({ length: size }, () => Array(size).fill(\"\"));\n  let wordPlacements = [];\n  let usedCoordinates = [];\n\n  words.forEach((word) => {\n    let isolatedOrOverlapAndIsolated = [];\n    let overlappingButNotIsolated = [];\n    let nonIsolated = [];\n\n    for (let row = 0; row < size; row++) {\n      for (let col = 0; col < size; col++) {\n        directions.forEach((direction) => {\n          const { fits, hasOverlap, isIsolated } = canFitWord(\n            grid,\n            word,\n            row,\n            col,\n            direction,\n            simpleMode\n          );\n          if (fits) {\n            const placement = { word, startRow: row, startCol: col, direction };\n            if (isIsolated) {\n              isolatedOrOverlapAndIsolated.push(placement);\n              if (hasOverlap) {\n                isolatedOrOverlapAndIsolated.push(placement);\n                isolatedOrOverlapAndIsolated.push(placement);\n                isolatedOrOverlapAndIsolated.push(placement);\n                isolatedOrOverlapAndIsolated.push(placement); // Add quad to increase likelihood of selection\n              }\n            } else if (hasOverlap) {\n              overlappingButNotIsolated.push(placement);\n            } else {\n              nonIsolated.push(placement);\n            }\n          }\n        });\n      }\n    }\n\n    // Selection logic\n    let selectedPossibilities =\n      isolatedOrOverlapAndIsolated.length > 0\n        ? isolatedOrOverlapAndIsolated\n        : overlappingButNotIsolated.length > 0\n        ? overlappingButNotIsolated\n        : nonIsolated;\n\n    if (selectedPossibilities.length > 0) {\n      const selectedPlacement =\n        selectedPossibilities[\n          Math.floor(Math.random() * selectedPossibilities.length)\n        ];\n      fitWord(\n        grid,\n        selectedPlacement.word,\n        selectedPlacement.startRow,\n        selectedPlacement.startCol,\n        selectedPlacement.direction\n      );\n      wordPlacements.push(selectedPlacement);\n      // Update usedCoordinates based on the selected placement\n      for (let i = 0; i < word.length; i++) {\n        const row =\n          selectedPlacement.startRow + i * selectedPlacement.direction.dy;\n        const col =\n          selectedPlacement.startCol + i * selectedPlacement.direction.dx;\n        usedCoordinates.push(`${row}-${col}`);\n      }\n    } else {\n      // Returning early with failure state if no placement is possible for a word\n      return { grid: [], wordPlacements: [], usedCoordinates: [] };\n    }\n  });\n\n  // Fill in remaining letters\n  for (let row = 0; row < size; row++) {\n    for (let col = 0; col < size; col++) {\n      if (grid[row][col] === \"\") {\n        grid[row][col] = String.fromCharCode(\n          Math.floor(Math.random() * 26) + 65\n        );\n      }\n    }\n  }\n\n  return { grid, wordPlacements, usedCoordinates };\n}\n\nfunction canFitWord(grid, word, startRow, startCol, direction, noOverlap) {\n  let hasOverlap = false;\n  let isIsolated = true;\n  // Make a deep copy of the grid\n  let gridCopy = grid.map((row) => row.slice());\n\n  for (let i = 0; i < word.length; i++) {\n    const row = startRow + i * direction.dy;\n    const col = startCol + i * direction.dx;\n\n    if (row < 0 || row >= grid.length || col < 0 || col >= grid[0].length) {\n      return { fits: false, hasOverlap: false, isIsolated: false };\n    }\n\n    if (grid[row][col] !== \"\" && grid[row][col] !== word[i]) {\n      return { fits: false, hasOverlap: false, isIsolated: false };\n    }\n\n    if (grid[row][col] === word[i]) {\n      hasOverlap = true;\n      if (noOverlap) {\n        return { fits: false, hasOverlap: true, isIsolated: false };\n      }\n      // Set the overlap point and its adjacent squares to empty in the copy\n      setEmptyInGridCopy(gridCopy, row, col);\n    }\n  }\n\n  // Perform the isolation check on the modified grid copy\n  isIsolated = checkIsolated(\n    gridCopy,\n    startRow,\n    startCol,\n    word.length,\n    direction\n  );\n\n  return { fits: true, hasOverlap, isIsolated };\n}\n\nfunction setEmptyInGridCopy(gridCopy, row, col) {\n  const adjacentPositions = [\n    { dx: -1, dy: -1 },\n    { dx: 0, dy: -1 },\n    { dx: 1, dy: -1 },\n    { dx: -1, dy: 0 },\n    { dx: 1, dy: 0 },\n    { dx: -1, dy: 1 },\n    { dx: 0, dy: 1 },\n    { dx: 1, dy: 1 },\n  ];\n  adjacentPositions.forEach(({ dx, dy }) => {\n    const adjRow = row + dy;\n    const adjCol = col + dx;\n    if (\n      adjRow >= 0 &&\n      adjRow < gridCopy.length &&\n      adjCol >= 0 &&\n      adjCol < gridCopy[0].length\n    ) {\n      gridCopy[adjRow][adjCol] = \"\"; // Set adjacent cells to empty\n    }\n  });\n  gridCopy[row][col] = \"\"; // Also set the overlap cell itself to empty\n}\n\nfunction checkIsolated(gridCopy, startRow, startCol, wordLength, direction) {\n  for (let i = 0; i < wordLength; i++) {\n    const row = startRow + i * direction.dy;\n    const col = startCol + i * direction.dx;\n\n    // Simply check adjacent cells in the grid copy for emptiness\n    if (!areAdjacentCellsEmpty(gridCopy, row, col)) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction areAdjacentCellsEmpty(gridCopy, row, col) {\n  const adjacentPositions = [\n    { dx: -1, dy: -1 },\n    { dx: 0, dy: -1 },\n    { dx: 1, dy: -1 },\n    { dx: -1, dy: 0 },\n    { dx: 1, dy: 0 },\n    { dx: -1, dy: 1 },\n    { dx: 0, dy: 1 },\n    { dx: 1, dy: 1 },\n  ];\n  for (const { dx, dy } of adjacentPositions) {\n    const adjRow = row + dy;\n    const adjCol = col + dx;\n    if (\n      adjRow >= 0 &&\n      adjRow < gridCopy.length &&\n      adjCol >= 0 &&\n      adjCol < gridCopy[0].length\n    ) {\n      if (gridCopy[adjRow][adjCol] !== \"\") {\n        return false; // Found a non-empty adjacent cell\n      }\n    }\n  }\n  return true; // All adjacent cells are empty\n}\n\nconst fitWord = (grid, word, startRow, startCol, direction) => {\n  for (let i = 0; i < word.length; i++) {\n    const row = startRow + i * direction.dy;\n    const col = startCol + i * direction.dx;\n    grid[row][col] = word[i];\n  }\n};\n\nexport default WordSearch;\n"],"names":["generateWordSearch","size","words","simpleMode","directions","dx","dy","grid","Array","from","length","fill","wordPlacements","usedCoordinates","forEach","word","isolatedOrOverlapAndIsolated","overlappingButNotIsolated","nonIsolated","row","col","direction","fits","hasOverlap","isIsolated","canFitWord","placement","startRow","startCol","push","selectedPossibilities","selectedPlacement","Math","floor","random","fitWord","i","concat","String","fromCharCode","noOverlap","gridCopy","map","slice","setEmptyInGridCopy","wordLength","areAdjacentCellsEmpty","checkIsolated","_ref2","adjRow","adjCol","adjacentPositions","_ref","text","gridSize","setGridSize","useState","showWords","setShowWords","title","setTitle","setWords","setGrid","revealWords","setRevealWords","setWordPlacements","setUsedCoordinates","selectedLetters","setSelectedLetters","foundWords","setFoundWords","wordsToFind","setWordsToFind","failed","setFailed","isPartOfWord","rowIndex","colIndex","includes","useEffect","lines","split","options","sizeChoice","showChoice","option","key","value","trim","toLowerCase","parseInt","uppercaseWordsList","filter","toUpperCase","some","attempts","success","markWordAsFound","prevCount","checkSelectedWord","selectedCells","startCell","endCell","selectedStartRow","selectedStartCol","Number","selectedEndRow","selectedEndCol","_jsxs","_Fragment","children","_jsx","className","styles","style","gridTemplateColumns","cell","foundWord","isPartOfFoundWord","onClick","handleCellClick","selectedCell","updatedSelectedLetters","splice","index","handleReveal"],"sourceRoot":""}