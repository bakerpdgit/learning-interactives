{"version":3,"file":"static/js/4593.a00cff71.chunk.js","mappings":"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","sources":["webpack://class-interactives/./src/components/MatchDragDrop.module.css?b995","components/MatchDragDrop.js","components/MathComponent.js"],"sourcesContent":["// extracted by mini-css-extract-plugin\nexport default {\"matchContainer\":\"MatchDragDrop_matchContainer__mG-8X\",\"terms\":\"MatchDragDrop_terms__lA9-v\",\"definitions\":\"MatchDragDrop_definitions__hSv4O\",\"draggable\":\"MatchDragDrop_draggable__3P3F6\",\"droppable\":\"MatchDragDrop_droppable__MDZsU\",\"correct\":\"MatchDragDrop_correct__DO1KH\",\"wrong\":\"MatchDragDrop_wrong__7WIya\",\"finishedTerm\":\"MatchDragDrop_finishedTerm__uOyPL\",\"finishedDefinition\":\"MatchDragDrop_finishedDefinition__w76o0\",\"celebration\":\"MatchDragDrop_celebration__qYDBq\",\"bounce\":\"MatchDragDrop_bounce__R7g1a\"};","import React, { useState, useEffect } from \"react\";\nimport { DragDropContext, Draggable, Droppable } from \"@hello-pangea/dnd\";\nimport styles from \"./MatchDragDrop.module.css\";\nimport MathComponent from \"./MathComponent.js\";\n\nfunction MatchDragDrop({ text }) {\n  const originalPairs = text.split(\"\\n\\n\").map((pair) => {\n    const [term, ...definition] = pair.split(\"\\n\");\n    return { term, definition: definition.join(\" \") };\n  });\n\n  const shuffled = (array) => {\n    let shuffledArray = [...array];\n    for (let i = shuffledArray.length - 1; i > 0; i--) {\n      const j = Math.floor(Math.random() * (i + 1));\n      [shuffledArray[i], shuffledArray[j]] = [\n        shuffledArray[j],\n        shuffledArray[i],\n      ];\n    }\n    return shuffledArray;\n  };\n\n  const [terms, setTerms] = useState(\n    shuffled(\n      originalPairs.map((p, idx) => ({\n        id: `term-${idx}`,\n        content: p.term,\n      }))\n    )\n  );\n\n  const [definitions, setDefinitions] = useState(\n    shuffled(\n      originalPairs.map((p, idx) => ({\n        id: `def-${idx}`,\n        termId: `term-${idx}`,\n        content: p.definition,\n      }))\n    )\n  );\n\n  const [matchedPairs, setMatchedPairs] = useState([]);\n  const [wrongMatch, setWrongMatch] = useState(null);\n  const [correctMatch, setCorrectMatch] = useState(null);\n  const [showCelebration, setShowCelebration] = useState(false);\n  const [showFinalResult, setShowFinalResult] = useState(false);\n\n  // Check if all pairs have been matched\n  useEffect(() => {\n    if (matchedPairs.length === originalPairs.length) {\n      setShowCelebration(true);\n      setTimeout(() => {\n        setShowCelebration(false);\n        setShowFinalResult(true);\n      }, 3000); // 3-second celebration\n    }\n  }, [matchedPairs, originalPairs.length]);\n\n  const onDragEnd = (result) => {\n    // eslint-disable-next-line no-unused-vars\n    const { source, destination, draggableId } = result;\n\n    // Dropped outside a droppable area\n    if (!destination) return;\n\n    // If dropped back to the terms area, do nothing\n    if (destination.droppableId === \"terms\") {\n      return;\n    }\n\n    // Only proceed if dropped into a definition area\n    if (destination.droppableId.startsWith(\"def-\")) {\n      const defIndex = definitions.findIndex(\n        (def) => def.id === destination.droppableId\n      );\n\n      if (definitions[defIndex].termId === draggableId) {\n        // Correct match\n        setCorrectMatch(definitions[defIndex].id);\n        setTimeout(() => {\n          setCorrectMatch(null);\n          setMatchedPairs((prevState) => [...prevState, draggableId]);\n\n          // Remove the matched term and definition from the lists\n          setTerms((prevTerms) =>\n            prevTerms.filter((term) => term.id !== draggableId)\n          );\n          setDefinitions((prevDefs) =>\n            prevDefs.filter((def) => def.id !== destination.droppableId)\n          );\n        }, 500);\n      } else {\n        // Incorrect match\n        setWrongMatch(definitions[defIndex].id);\n        setTimeout(() => {\n          setWrongMatch(null);\n        }, 500);\n      }\n    }\n  };\n\n  return (\n    <>\n      {showFinalResult ? (\n        <div className={styles.matchContainer}>\n          <div className={styles.terms}>\n            {originalPairs.map((pair, index) => (\n              <div key={index} className={styles.finishedTerm}>\n                <MathComponent text={pair.term} renderNewLines={true} />\n              </div>\n            ))}\n          </div>\n          <div className={styles.definitions}>\n            {originalPairs.map((pair, index) => (\n              <div key={index} className={styles.finishedDefinition}>\n                <MathComponent text={pair.definition} renderNewLines={true} />\n              </div>\n            ))}\n          </div>\n        </div>\n      ) : showCelebration ? (\n        <div className={styles.celebration}>ðŸŽ‰</div>\n      ) : (\n        <DragDropContext onDragEnd={onDragEnd}>\n          <div className={styles.matchContainer}>\n            {/* Wrap terms in a Droppable */}\n            <Droppable droppableId=\"terms\" isDropDisabled={true}>\n              {(provided) => (\n                <div\n                  className={styles.terms}\n                  ref={provided.innerRef}\n                  {...provided.droppableProps}\n                >\n                  {terms.map((term, index) => (\n                    <Draggable\n                      key={term.id}\n                      draggableId={term.id}\n                      index={index}\n                    >\n                      {(provided) => (\n                        <div\n                          className={styles.draggable}\n                          ref={provided.innerRef}\n                          {...provided.draggableProps}\n                          {...provided.dragHandleProps}\n                        >\n                          <MathComponent\n                            text={term.content}\n                            renderNewLines={true}\n                          />\n                        </div>\n                      )}\n                    </Draggable>\n                  ))}\n                  {provided.placeholder}\n                </div>\n              )}\n            </Droppable>\n            <div className={styles.definitions}>\n              {definitions.map((definition) => {\n                const isMatched = matchedPairs.includes(definition.termId);\n\n                return (\n                  <Droppable\n                    key={definition.id}\n                    droppableId={definition.id}\n                    isDropDisabled={isMatched}\n                  >\n                    {(provided) => (\n                      <div\n                        className={`${styles.droppable} ${\n                          correctMatch === definition.id\n                            ? styles.correct\n                            : wrongMatch === definition.id\n                            ? styles.wrong\n                            : \"\"\n                        }`}\n                        ref={provided.innerRef}\n                        {...provided.droppableProps}\n                      >\n                        <MathComponent\n                          text={definition.content}\n                          renderNewLines={true}\n                        />\n                        {provided.placeholder}\n                      </div>\n                    )}\n                  </Droppable>\n                );\n              })}\n            </div>\n          </div>\n        </DragDropContext>\n      )}\n    </>\n  );\n}\n\nexport default MatchDragDrop;\n","import { InlineMath } from \"react-katex\";\n\nfunction parseAndRenderMath(text) {\n  const prefix = Math.random().toString(36).substring(2, 10); // Generate an 8-character random string\n\n  // Split the text based on $$ delimiters\n  const segments = text.split(\"$$\");\n  const elements = [];\n\n  segments.forEach((segment, index) => {\n    if (index % 2 === 1) {\n      // Odd-indexed segments are LaTeX (since they are enclosed between $$ delimiters)\n      elements.push(\n        <InlineMath key={`MCIM-${prefix}-${index}`} math={segment} />\n      );\n    } else {\n      elements.push(<span key={`MCSP-${prefix}-${index}`}>{segment}</span>);\n    }\n  });\n\n  return elements;\n}\n\nconst renderWithNewLines = (text) => {\n  return text.replace(/\\\\n/g, \"\\n\");\n};\n\nfunction MathComponent({ text, renderNewLines = false }) {\n  if (renderNewLines) {\n    text = renderWithNewLines(text);\n  }\n\n  return (\n    <div\n      style={{\n        whiteSpace:\n          text.includes(\"\\n\") && renderNewLines ? \"pre-wrap\" : \"normal\",\n        marginTop: text.includes(\"$$\") ? \"0.5em\" : \"0\",\n      }}\n    >\n      {parseAndRenderMath(text)}\n    </div>\n  );\n}\n\nexport default MathComponent;\n"],"names":["_ref","text","originalPairs","split","map","pair","term","definition","join","shuffled","array","shuffledArray","i","length","j","Math","floor","random","terms","setTerms","useState","p","idx","id","concat","content","definitions","setDefinitions","termId","matchedPairs","setMatchedPairs","wrongMatch","setWrongMatch","correctMatch","setCorrectMatch","showCelebration","setShowCelebration","showFinalResult","setShowFinalResult","useEffect","setTimeout","_jsx","_Fragment","children","_jsxs","className","styles","index","MathComponent","renderNewLines","DragDropContext","onDragEnd","result","source","destination","draggableId","droppableId","startsWith","defIndex","findIndex","def","prevState","prevTerms","filter","prevDefs","Droppable","isDropDisabled","provided","ref","innerRef","droppableProps","Draggable","draggableProps","dragHandleProps","placeholder","isMatched","includes","parseAndRenderMath","prefix","toString","substring","segments","elements","forEach","segment","push","InlineMath","math","replace","renderWithNewLines","style","whiteSpace","marginTop"],"sourceRoot":""}