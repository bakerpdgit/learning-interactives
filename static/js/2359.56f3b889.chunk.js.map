{"version":3,"file":"static/js/2359.56f3b889.chunk.js","mappings":"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","sources":["webpack://class-interactives/./src/components/OrderedLine.module.css?5e51","components/OrderedLine.js"],"sourcesContent":["// extracted by mini-css-extract-plugin\nexport default {\"heading\":\"OrderedLine_heading__wWNUS\",\"orderedLineCanvas\":\"OrderedLine_orderedLineCanvas__-WOJx\",\"addItem\":\"OrderedLine_addItem__L8-ef\",\"addItemBar\":\"OrderedLine_addItemBar__C11FA\"};","import React, { useRef, useEffect, useState } from \"react\";\nimport InputModal from \"./InputModal\"; // <-- Adjust the import path to match your setup\nimport styles from \"./OrderedLine.module.css\";\n\nfunction OrderedLineCanvas({ text }) {\n  // ------------------ State ------------------\n  // We store the 'items' (the draggable text boxes) in state so we can add new ones.\n  const [items, setItems] = useState([]);\n  const [labels, setLabels] = useState([]);\n  const [isModalOpen, setIsModalOpen] = useState(false);\n\n  // ------------------ Refs for Canvas & Positions ------------------\n  const canvasRef = useRef(null);\n  const boxCoordinatesRef = useRef([]); // X positions of boxes\n  const labelYPositionsRef = useRef([]); // Y positions of boxes\n  const boxDimensionsRef = useRef([]); // [{ width, height }, ...] for each box\n  const lineYRef = useRef(0); // The y-coordinate of the main timeline\n\n  // ------------------ Refs for Drag/Resize Flags ------------------\n  const isDraggingLabelRef = useRef(false);\n  const draggedLabelIndexRef = useRef(null);\n\n  const isDraggingMarkerRef = useRef(false);\n  const draggedMarkerIndexRef = useRef(null);\n\n  const isResizingTopRef = useRef(false);\n  const isResizingRightRef = useRef(false);\n  const resizingBoxIndexRef = useRef(null);\n\n  // ------------------ Constants ------------------\n  const textBoxDefaultHeight = 30;\n  const textBoxDefaultWidthPad = 10;\n  const markerSize = 10;\n  const handleSize = 10;\n\n  // ------------------ Parse Text (Once) ------------------\n  //   1. The first line \"labelLine\" has something like:  \"Start-End\"\n  //   2. The rest become items. We store them in React state.\n  useEffect(() => {\n    const lines = text.split(\"\\n\").filter((item) => item.trim());\n    if (lines.length < 1) return;\n\n    const [labelLine, ...rest] = lines;\n    const [labelLeft, labelRight] = labelLine.split(\"-\");\n\n    setLabels([labelLeft, labelRight]);\n    // Shuffle or randomize the item lines:\n    const shuffled = rest.sort(() => Math.random() - 0.5);\n    setItems(shuffled);\n  }, [text]);\n\n  /**\n   * Wraps text into multiple lines based on the maximum width.\n   *\n   * @param {CanvasRenderingContext2D} ctx - The canvas context.\n   * @param {string} text - The text to wrap.\n   * @param {number} maxWidth - The maximum width of each line.\n   * @returns {string[]} - An array of text lines.\n   */\n  function wrapText(ctx, text, maxWidth) {\n    const words = text.split(\" \");\n    const lines = [];\n    let currentLine = \"\";\n\n    words.forEach((word) => {\n      const testLine = currentLine ? `${currentLine} ${word}` : word;\n      const { width } = ctx.measureText(testLine);\n      if (width > maxWidth && currentLine) {\n        lines.push(currentLine);\n        currentLine = word;\n      } else {\n        currentLine = testLine;\n      }\n    });\n\n    if (currentLine) {\n      lines.push(currentLine);\n    }\n\n    return lines;\n  }\n\n  // ------------------ Initialize & Draw (Runs whenever items or labels change) ------------------\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    const ctx = canvas.getContext(\"2d\");\n\n    // On window resize, re-initialize & re-draw\n    function handleResize() {\n      const dpr = window.devicePixelRatio || 1;\n      canvas.width = canvas.offsetWidth * dpr;\n      canvas.height = canvas.offsetHeight * dpr;\n      ctx.scale(dpr, dpr);\n      lineYRef.current = (canvas.height * 0.92) / dpr;\n      initializePositions(ctx, dpr, true);\n      draw(ctx, dpr);\n    }\n    window.addEventListener(\"resize\", handleResize);\n\n    // First-time setup: set canvas size, then init/draw\n    const dpr = window.devicePixelRatio || 1;\n    canvas.width = canvas.offsetWidth * dpr;\n    canvas.height = canvas.offsetHeight * dpr;\n    ctx.scale(dpr, dpr);\n\n    lineYRef.current = (canvas.height * 0.92) / dpr;\n\n    // ------------------ Initialize Positions ------------------\n    function initializePositions(context, pixelRatio, forceReset = false) {\n      // Clear any prior references\n      const newBoxCoordinates = [];\n      const newLabelYPositions = [];\n      const newBoxDimensions = [];\n\n      items.forEach((item, i) => {\n        // retain current if present else set to spread out default\n\n        // Spread them out horizontally\n        let xPos = ((i + 1) * canvas.width) / (items.length + 1) / pixelRatio;\n\n        if (boxCoordinatesRef.current[i] && !forceReset) {\n          xPos = boxCoordinatesRef.current[i];\n        }\n\n        newBoxCoordinates.push(xPos);\n\n        // Random or default vertical position\n        const minY = textBoxDefaultHeight / 2 + 10;\n        const maxY =\n          lineYRef.current - markerSize - textBoxDefaultHeight / 2 - 10;\n        let yPos = Math.random() * (maxY - minY) + minY;\n\n        if (labelYPositionsRef.current[i] && !forceReset) {\n          yPos = labelYPositionsRef.current[i];\n        }\n\n        newLabelYPositions.push(yPos);\n\n        // Measure text width\n        context.font = \"16px Arial\";\n        let textWidth =\n          context.measureText(item).width + textBoxDefaultWidthPad * 2;\n        let textBoxHeight = textBoxDefaultHeight;\n\n        if (boxDimensionsRef.current[i] && !forceReset) {\n          textWidth = boxDimensionsRef.current[i].width;\n          textBoxHeight = boxDimensionsRef.current[i].height;\n        }\n\n        newBoxDimensions.push({\n          width: textWidth,\n          height: textBoxHeight,\n        });\n      });\n\n      // Update the refs\n      boxCoordinatesRef.current = newBoxCoordinates;\n      labelYPositionsRef.current = newLabelYPositions;\n      boxDimensionsRef.current = newBoxDimensions;\n    }\n\n    initializePositions(ctx, dpr);\n\n    // ------------------ Draw ------------------\n    function draw(context, pixelRatio) {\n      context.clearRect(\n        0,\n        0,\n        canvas.width / pixelRatio,\n        canvas.height / pixelRatio\n      );\n\n      // 1) Draw main line\n      context.strokeStyle = \"#000\";\n      context.lineWidth = 2;\n      context.beginPath();\n      context.moveTo(10, lineYRef.current);\n      context.lineTo(canvas.width / pixelRatio - 10, lineYRef.current);\n      context.stroke();\n\n      // 2) Draw labels\n      if (labels.length === 2) {\n        context.font = \"16px Arial\";\n        context.textAlign = \"left\";\n        context.fillText(labels[0], 10, lineYRef.current + 20);\n\n        context.textAlign = \"right\";\n        context.fillText(\n          labels[1],\n          canvas.width / pixelRatio - 10,\n          lineYRef.current + 20\n        );\n      }\n\n      // 3) Draw each item with wrapped text\n      items.forEach((item, i) => {\n        const x = boxCoordinatesRef.current[i];\n        const yLabel = labelYPositionsRef.current[i];\n        let { width: boxWidth, height: boxHeight } =\n          boxDimensionsRef.current[i];\n\n        // Wrap text\n        context.font = \"16px Arial\";\n        context.textAlign = \"center\";\n        context.textBaseline = \"top\"; // Start from the top of the box\n        context.fillStyle = \"#000\";\n\n        const maxTextWidth = boxWidth - textBoxDefaultWidthPad * 2;\n        const lines = wrapText(context, item, maxTextWidth);\n        const padding = 6;\n\n        const lineHeight = 18; // Adjust based on font size\n        const totalTextHeight = lines.length * lineHeight;\n\n        // Auto-calculate box height based on text lines with reduced bottom padding\n        boxHeight = Math.max(\n          textBoxDefaultHeight + padding,\n          totalTextHeight + padding\n        );\n        boxDimensionsRef.current[i].height = boxHeight;\n\n        // Calculate starting Y-coordinate for vertically centered text\n        const textStartY = yLabel - totalTextHeight / 2;\n\n        // Box background and border\n        context.fillStyle = \"#f0f0f0\";\n        context.fillRect(\n          x - boxWidth / 2,\n          yLabel - boxHeight / 2,\n          boxWidth,\n          boxHeight\n        );\n        context.strokeStyle = \"#000\";\n        context.strokeRect(\n          x - boxWidth / 2,\n          yLabel - boxHeight / 2,\n          boxWidth,\n          boxHeight\n        );\n\n        // Set text properties\n        context.font = \"16px Arial\";\n        context.textAlign = \"center\";\n        context.textBaseline = \"top\"; // Start from the top of the text block\n        context.fillStyle = \"#000\"; // Ensure text color is black\n\n        // Render each line of text, centered vertically\n        lines.forEach((line, lineIndex) => {\n          context.fillText(line, x, textStartY + lineIndex * lineHeight);\n        });\n\n        // Vertical line from box to main timeline\n        context.beginPath();\n        context.moveTo(x, yLabel + boxHeight / 2);\n        context.lineTo(x, lineYRef.current - markerSize / 2);\n        context.stroke();\n\n        // Marker\n        context.fillStyle = \"#000\";\n        context.fillRect(\n          x - markerSize / 2,\n          lineYRef.current - markerSize / 2,\n          markerSize,\n          markerSize\n        );\n\n        // Right handle\n        context.fillRect(\n          x + boxWidth / 2 - handleSize / 4,\n          yLabel - handleSize / 2,\n          handleSize / 2,\n          handleSize\n        );\n      });\n    }\n\n    // Perform initial draw\n    draw(ctx, dpr);\n\n    // ------------------ Utility for checking if point in rect ------------------\n    function isPointInRect(px, py, rect) {\n      return (\n        px >= rect.x &&\n        px <= rect.x + rect.width &&\n        py >= rect.y &&\n        py <= rect.y + rect.height\n      );\n    }\n\n    // ------------------ MouseDown ------------------\n    function handleMouseDown(e) {\n      const rect = canvas.getBoundingClientRect();\n      const mouseX = e.clientX - rect.left;\n      const mouseY = e.clientY - rect.top;\n\n      // Reset all flags to false by default\n      isDraggingMarkerRef.current = false;\n      draggedMarkerIndexRef.current = null;\n      isResizingTopRef.current = false;\n      isResizingRightRef.current = false;\n      resizingBoxIndexRef.current = null;\n      isDraggingLabelRef.current = false;\n      draggedLabelIndexRef.current = null;\n\n      for (let i = 0; i < items.length; i++) {\n        const x = boxCoordinatesRef.current[i];\n        const yLabel = labelYPositionsRef.current[i];\n        const { width: boxWidth, height: boxHeight } =\n          boxDimensionsRef.current[i];\n\n        // Marker rect\n        const markerRect = {\n          x: x - markerSize / 2,\n          y: lineYRef.current - markerSize / 2,\n          width: markerSize,\n          height: markerSize,\n        };\n        // Box rect\n        const boxRect = {\n          x: x - boxWidth / 2,\n          y: yLabel - boxHeight / 2,\n          width: boxWidth,\n          height: boxHeight,\n        };\n\n        // Right handle rect\n        const rightHandleRect = {\n          x: x + boxWidth / 2 - handleSize / 4,\n          y: yLabel - handleSize / 2,\n          width: handleSize / 2,\n          height: handleSize,\n        };\n\n        // Check marker\n        if (isPointInRect(mouseX, mouseY, markerRect)) {\n          isDraggingMarkerRef.current = true;\n          draggedMarkerIndexRef.current = i;\n          break;\n        }\n\n        // Check right handle\n        if (isPointInRect(mouseX, mouseY, rightHandleRect)) {\n          isResizingRightRef.current = true;\n          resizingBoxIndexRef.current = i;\n          break;\n        }\n        // Check box\n        if (isPointInRect(mouseX, mouseY, boxRect)) {\n          isDraggingLabelRef.current = true;\n          draggedLabelIndexRef.current = i;\n          break;\n        }\n      }\n    }\n\n    // ------------------ MouseMove ------------------\n    function handleMouseMove(e) {\n      const rect = canvas.getBoundingClientRect();\n      const mouseX = e.clientX - rect.left;\n      const mouseY = e.clientY - rect.top;\n\n      // First, handle cursor changes\n      canvas.style.cursor = \"default\";\n\n      for (let i = 0; i < items.length; i++) {\n        const x = boxCoordinatesRef.current[i];\n        const yLabel = labelYPositionsRef.current[i];\n        const { width: boxWidth, height: boxHeight } =\n          boxDimensionsRef.current[i];\n\n        const markerRect = {\n          x: x - markerSize / 2,\n          y: lineYRef.current - markerSize / 2,\n          width: markerSize,\n          height: markerSize,\n        };\n\n        const rightHandleRect = {\n          x: x + boxWidth / 2 - handleSize / 4,\n          y: yLabel - handleSize / 2,\n          width: handleSize / 2,\n          height: handleSize,\n        };\n        const boxRect = {\n          x: x - boxWidth / 2,\n          y: yLabel - boxHeight / 2,\n          width: boxWidth,\n          height: boxHeight,\n        };\n\n        if (isPointInRect(mouseX, mouseY, markerRect)) {\n          canvas.style.cursor = \"ns-resize\";\n          break;\n        } else if (isPointInRect(mouseX, mouseY, rightHandleRect)) {\n          canvas.style.cursor = \"ew-resize\";\n          break;\n        } else if (isPointInRect(mouseX, mouseY, boxRect)) {\n          canvas.style.cursor = \"move\";\n          break;\n        }\n      }\n\n      // Second, handle active dragging/resizing\n      if (isDraggingLabelRef.current && draggedLabelIndexRef.current !== null) {\n        const canvas = canvasRef.current;\n        const dpr = window.devicePixelRatio || 1;\n        const renderedWidth = canvas.width / dpr;\n\n        // Define boundaries\n        const minX = 10;\n        const maxX = renderedWidth - 10;\n\n        // Clamp the mouseX within [minX, maxX]\n        const clampedX = Math.min(Math.max(mouseX, minX), maxX);\n\n        // Update the x-coordinate with the clamped value\n        boxCoordinatesRef.current[draggedLabelIndexRef.current] = clampedX;\n        draw(ctx, dpr);\n      } else if (\n        isDraggingMarkerRef.current &&\n        draggedMarkerIndexRef.current !== null\n      ) {\n        // Move the text vertically (marker drags the text)\n        const minY = textBoxDefaultHeight / 2 + 10;\n        const maxY =\n          lineYRef.current - markerSize - textBoxDefaultHeight / 2 - 50;\n        const newY = Math.min(Math.max(mouseY, minY), maxY);\n        labelYPositionsRef.current[draggedMarkerIndexRef.current] = newY;\n        draw(ctx, dpr);\n      } else if (\n        isResizingTopRef.current &&\n        resizingBoxIndexRef.current !== null\n      ) {\n        // Resize height\n        const i = resizingBoxIndexRef.current;\n        const yLabel = labelYPositionsRef.current[i];\n        const currentHeight = boxDimensionsRef.current[i].height;\n        const boxTop = yLabel - currentHeight / 2;\n        const diff = boxTop - mouseY;\n        const newHeight = currentHeight + diff;\n        if (newHeight > 20) {\n          boxDimensionsRef.current[i].height = newHeight;\n        }\n        draw(ctx, dpr);\n      } else if (\n        isResizingRightRef.current &&\n        resizingBoxIndexRef.current !== null\n      ) {\n        // Resize width\n        const i = resizingBoxIndexRef.current;\n        const currentWidth = boxDimensionsRef.current[i].width;\n        const x = boxCoordinatesRef.current[i];\n        const boxRight = x + currentWidth / 2;\n        const diff = mouseX - boxRight;\n        const newWidth = currentWidth + diff;\n        if (newWidth > 20) {\n          boxDimensionsRef.current[i].width = newWidth;\n        }\n        draw(ctx, dpr);\n      }\n    }\n\n    // ------------------ MouseUp ------------------\n    function handleMouseUp() {\n      // Release everything\n      isDraggingMarkerRef.current = false;\n      draggedMarkerIndexRef.current = null;\n      isResizingTopRef.current = false;\n      isResizingRightRef.current = false;\n      resizingBoxIndexRef.current = null;\n      isDraggingLabelRef.current = false;\n      draggedLabelIndexRef.current = null;\n    }\n\n    // Add listeners\n    canvas.addEventListener(\"mousedown\", handleMouseDown);\n    window.addEventListener(\"mousemove\", handleMouseMove);\n    window.addEventListener(\"mouseup\", handleMouseUp);\n\n    return () => {\n      canvas.removeEventListener(\"mousedown\", handleMouseDown);\n      window.removeEventListener(\"mousemove\", handleMouseMove);\n      window.removeEventListener(\"mouseup\", handleMouseUp);\n      window.removeEventListener(\"resize\", handleResize);\n    };\n  }, [items, labels]);\n\n  // ------------------ Modal and \"Add Item\" Logic ------------------\n  const openAddItemModal = () => {\n    setIsModalOpen(true);\n  };\n\n  const handleAddItemSubmit = (userInput) => {\n    if (userInput.trim()) {\n      // Insert new item at the end (or in the middle, if desired)\n      setItems((prev) => [...prev, userInput.trim()]);\n    }\n    setIsModalOpen(false);\n  };\n\n  return (\n    <div className={styles.orderedLineContainer}>\n      {/* (1) \"Add Item\" button */}\n      <div className={styles.addItemBar}>\n        <button className={styles.addItem} onClick={openAddItemModal}>\n          Add Item\n        </button>\n      </div>\n\n      {/* (2) The InputModal (single-line) */}\n      {isModalOpen && (\n        <InputModal\n          title=\"Add a New Item\"\n          placeholder=\"Type your item here...\"\n          value=\"\"\n          onSubmit={handleAddItemSubmit}\n          onClose={() => setIsModalOpen(false)}\n          multiLine={false}\n        />\n      )}\n\n      {/* (3) The Canvas */}\n      <div className={styles.orderedLineCanvasContainer}>\n        <canvas ref={canvasRef} className={styles.orderedLineCanvas}></canvas>\n      </div>\n    </div>\n  );\n}\n\nexport default OrderedLineCanvas;\n"],"names":["_ref","text","items","setItems","useState","labels","setLabels","isModalOpen","setIsModalOpen","canvasRef","useRef","boxCoordinatesRef","labelYPositionsRef","boxDimensionsRef","lineYRef","isDraggingLabelRef","draggedLabelIndexRef","isDraggingMarkerRef","draggedMarkerIndexRef","isResizingTopRef","isResizingRightRef","resizingBoxIndexRef","textBoxDefaultHeight","markerSize","handleSize","useEffect","lines","split","filter","item","trim","length","labelLine","rest","labelLeft","labelRight","shuffled","sort","Math","random","canvas","current","ctx","getContext","handleResize","dpr","window","devicePixelRatio","width","offsetWidth","height","offsetHeight","scale","initializePositions","draw","addEventListener","context","pixelRatio","forceReset","arguments","undefined","newBoxCoordinates","newLabelYPositions","newBoxDimensions","forEach","i","xPos","push","maxY","yPos","font","textWidth","measureText","textBoxDefaultWidthPad","textBoxHeight","clearRect","strokeStyle","lineWidth","beginPath","moveTo","lineTo","stroke","textAlign","fillText","x","yLabel","boxWidth","boxHeight","textBaseline","fillStyle","maxWidth","words","currentLine","word","testLine","concat","wrapText","totalTextHeight","max","textStartY","fillRect","strokeRect","line","lineIndex","isPointInRect","px","py","rect","y","handleMouseDown","e","getBoundingClientRect","mouseX","clientX","left","mouseY","clientY","top","markerRect","boxRect","rightHandleRect","handleMouseMove","style","cursor","minX","maxX","clampedX","min","minY","newY","currentHeight","newHeight","currentWidth","newWidth","handleMouseUp","removeEventListener","_jsxs","className","styles","orderedLineContainer","children","_jsx","addItemBar","addItem","onClick","openAddItemModal","InputModal","title","placeholder","value","onSubmit","userInput","prev","onClose","multiLine","orderedLineCanvasContainer","ref","orderedLineCanvas"],"sourceRoot":""}