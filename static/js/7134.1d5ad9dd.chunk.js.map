{"version":3,"file":"static/js/7134.1d5ad9dd.chunk.js","mappings":"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","sources":["webpack://class-interactives/./src/components/PhraseMemorise.module.css?a4d7","components/PhraseMemorise.js"],"sourcesContent":["// extracted by mini-css-extract-plugin\nexport default {\"phraseMemoriseBox\":\"PhraseMemorise_phraseMemoriseBox__qw1We\",\"letter\":\"PhraseMemorise_letter__wBn6U\",\"clickableWord\":\"PhraseMemorise_clickableWord__X0GpL\"};","import React, { useState, useEffect } from \"react\";\nimport { IconButton } from \"@mui/material\";\nimport ArrowBackIcon from \"@mui/icons-material/ArrowBack\";\nimport ArrowForwardIcon from \"@mui/icons-material/ArrowForward\";\nimport styles from \"./PhraseMemorise.module.css\"; // Importing the CSS file\n\nfunction PhraseMemorise({ text }) {\n  const [phrases, setPhrases] = useState([]);\n  const [currentPhraseIndex, setCurrentPhraseIndex] = useState(0);\n  const [displayModes, setDisplayModes] = useState([]);\n  const [defaultDisplayMode, setDefaultDisplayMode] = useState(\"first\"); // Added for dynamic update\n\n  // Function to shuffle phrases if needed\n  const shuffleArray = (array) => {\n    for (let i = array.length - 1; i > 0; i--) {\n      const j = Math.floor(Math.random() * (i + 1));\n      [array[i], array[j]] = [array[j], array[i]]; // Swap elements\n    }\n    return array;\n  };\n\n  // Parse OPTIONS and initialize states\n  useEffect(() => {\n    const lines = text.split(\"\\n\");\n    const optionsLine = lines.find((line) => line.startsWith(\"OPTIONS:\"));\n    let order = \"maintain\"; // Default order\n\n    // Parsing the OPTIONS line\n    if (optionsLine) {\n      const optionsParts = optionsLine.split(\":\")[1].split(\",\");\n      optionsParts.forEach((part) => {\n        const [key, value] = part.split(\"=\");\n        if (key === \"show\") setDefaultDisplayMode(value);\n        if (key === \"order\") order = value;\n      });\n    }\n\n    let filteredPhrases = lines.filter(\n      (line) => line && !line.startsWith(\"OPTIONS:\")\n    );\n    if (order === \"random\") filteredPhrases = shuffleArray(filteredPhrases);\n\n    setPhrases(filteredPhrases);\n    setCurrentPhraseIndex(0);\n  }, [text]); // Re-run when text prop changes\n\n  // Update words and displayModes when currentPhraseIndex changes\n  useEffect(() => {\n    if (phrases.length > 0 && currentPhraseIndex < phrases.length) {\n      const words = phrases[currentPhraseIndex]\n        .split(\" \")\n        .filter((word) => word);\n      const newDisplayModes = words.map(() => {\n        if (defaultDisplayMode === \"all\") return \"full\";\n        if (defaultDisplayMode === \"none\") return \"hidden\";\n        return \"first\";\n      });\n      setDisplayModes(newDisplayModes);\n    }\n  }, [currentPhraseIndex, phrases, defaultDisplayMode]); // Re-run when any of these dependencies change\n\n  // Extract current words based on the currentPhraseIndex for rendering\n  const words =\n    phrases.length > 0 && currentPhraseIndex < phrases.length\n      ? phrases[currentPhraseIndex].split(\" \").filter((word) => word)\n      : [];\n\n  const toggleWord = (index) => {\n    const newModes = [...displayModes];\n    if (newModes[index] === \"full\") {\n      newModes[index] = \"hidden\";\n    } else if (newModes[index] === \"first\") {\n      newModes[index] = \"full\";\n    } else {\n      newModes[index] = \"first\";\n    }\n    setDisplayModes(newModes);\n  };\n\n  const renderWord = (word, mode) => {\n    if (mode === \"full\")\n      return word.split(\"\").map((letter, letterIndex) => (\n        <span key={letterIndex} className={styles.letter}>\n          {letter}\n        </span>\n      ));\n    if (mode === \"first\")\n      return [word.charAt(0), ...\"_\".repeat(word.length - 1).split(\"\")].map(\n        (letter, letterIndex) => (\n          <span key={letterIndex} className={styles.letter}>\n            {letter}\n          </span>\n        )\n      );\n    return \"_\"\n      .repeat(word.length)\n      .split(\"\")\n      .map((letter, letterIndex) => (\n        <span key={letterIndex} className={styles.letter}>\n          {letter}\n        </span>\n      ));\n  };\n\n  const handleNextPhrase = () => {\n    if (currentPhraseIndex < phrases.length - 1) {\n      setCurrentPhraseIndex(currentPhraseIndex + 1);\n      setDisplayModes(\n        phrases[currentPhraseIndex + 1].split(\" \").map(() => \"first\")\n      );\n    }\n  };\n\n  const handlePrevPhrase = () => {\n    if (currentPhraseIndex > 0) {\n      setCurrentPhraseIndex(currentPhraseIndex - 1);\n      setDisplayModes(\n        phrases[currentPhraseIndex - 1].split(\" \").map(() => \"first\")\n      );\n    }\n  };\n\n  const revealAllWords = () => {\n    setDisplayModes(new Array(words.length).fill(\"full\"));\n  };\n\n  const resetWords = () => {\n    setDisplayModes(words.map(() => defaultDisplayMode));\n  };\n\n  return (\n    <>\n      <div className={`interactiveContainer ${styles.phraseMemoriseContainer}`}>\n        <div className={styles.phraseMemoriseBox}>\n          {words.map((word, index) => (\n            <span\n              key={index}\n              className={styles.clickableWord}\n              onClick={() => toggleWord(index)}\n            >\n              {renderWord(word, displayModes[index])}{\" \"}\n            </span>\n          ))}\n        </div>\n        {phrases.length > 1 && (\n          <div className={styles.navigationButtons}>\n            <IconButton\n              onClick={handlePrevPhrase}\n              disabled={currentPhraseIndex === 0}\n            >\n              <ArrowBackIcon />\n            </IconButton>\n            <IconButton\n              onClick={handleNextPhrase}\n              disabled={currentPhraseIndex === phrases.length - 1}\n            >\n              <ArrowForwardIcon />\n            </IconButton>\n          </div>\n        )}\n        <div className={styles.actionButtons}>\n          <button onClick={revealAllWords}>Reveal</button>\n          <button onClick={resetWords}>Reset</button>\n        </div>\n      </div>\n    </>\n  );\n}\n\nexport default PhraseMemorise;\n"],"names":["_ref","text","phrases","setPhrases","useState","currentPhraseIndex","setCurrentPhraseIndex","displayModes","setDisplayModes","defaultDisplayMode","setDefaultDisplayMode","useEffect","lines","split","optionsLine","find","line","startsWith","order","forEach","part","key","value","filteredPhrases","filter","array","i","length","j","Math","floor","random","shuffleArray","newDisplayModes","word","map","words","renderWord","mode","letter","letterIndex","_jsx","className","styles","children","charAt","repeat","_Fragment","_jsxs","concat","phraseMemoriseContainer","phraseMemoriseBox","index","clickableWord","onClick","newModes","toggleWord","navigationButtons","IconButton","handlePrevPhrase","disabled","ArrowBackIcon","handleNextPhrase","ArrowForwardIcon","actionButtons","revealAllWords","Array","fill","resetWords"],"sourceRoot":""}