{"version":3,"file":"static/js/209.cf8fb436.chunk.js","mappings":"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","sources":["webpack://my-react-app/./src/components/WordSearch.module.css?1ff4","components/WordSearch.js"],"sourcesContent":["// extracted by mini-css-extract-plugin\nexport default {\"interactiveSubTitle\":\"WordSearch_interactiveSubTitle__A1P3Z\",\"GameArea\":\"WordSearch_GameArea__tAV2U\",\"RevealButton\":\"WordSearch_RevealButton__sQxtH\",\"Container\":\"WordSearch_Container__jr9bd\",\"WordSearchGrid\":\"WordSearch_WordSearchGrid__aeVss\",\"WordSearchRow\":\"WordSearch_WordSearchRow__ZqvBD\",\"WordSearchCell\":\"WordSearch_WordSearchCell__ohZaY\",\"WordList\":\"WordSearch_WordList__xjQX-\",\"RevealedCell\":\"WordSearch_RevealedCell__7EwFz\",\"SelectedCell\":\"WordSearch_SelectedCell__U1bv+\",\"FoundCell\":\"WordSearch_FoundCell__kpWJP\",\"FoundWord\":\"WordSearch_FoundWord__AOkoD\",\"celebration\":\"WordSearch_celebration__-OI9z\",\"scale\":\"WordSearch_scale__Ods1w\",\"hide\":\"WordSearch_hide__8wt9y\"};","import React, { useState, useEffect } from \"react\";\nimport styles from \"./WordSearch.module.css\";\n\nfunction WordSearch({ text }) {\n  const [gridSize, setGridSize] = useState(12);\n  const [showWords, setShowWords] = useState(false);\n  const [title, setTitle] = useState(\"\");\n  const [words, setWords] = useState([]);\n  const [grid, setGrid] = useState([]);\n  const [revealWords, setRevealWords] = useState(false);\n  const [allowReveal, setallowReveal] = useState(false);\n  const [wordPlacements, setWordPlacements] = useState([]);\n  const [usedCoordinates, setUsedCoordinates] = useState([]);\n  const [selectedLetters, setSelectedLetters] = useState([]);\n  const [foundWords, setFoundWords] = useState([]);\n  const [wordsToFind, setWordsToFind] = useState(words.length);\n  const [failed, setFailed] = useState(false);\n\n  useEffect(() => {\n    const lines = text.split(\"\\n\");\n    const optionsLine = lines[0];\n    const options = optionsLine.slice(8).split(\",\");\n    let simpleMode = false;\n    let sizeChoice = 10;\n    let showChoice = true;\n    let revealChoice = false;\n\n    options.forEach((option) => {\n      const [key, value] = option.split(\"=\");\n      if (key.trim().toLowerCase() === \"size\") {\n        sizeChoice = parseInt(value);\n        setGridSize(sizeChoice);\n      } else if (key.trim().toLowerCase() === \"show\") {\n        showChoice = value.trim().toLowerCase() === \"yes\";\n        setShowWords(showChoice);\n      } else if (key.trim().toLowerCase() === \"reveal\") {\n        revealChoice = value.trim().toLowerCase() === \"yes\";\n        setallowReveal(revealChoice);\n      } else if (key.trim().toLowerCase() === \"simple\") {\n        simpleMode = value.trim().toLowerCase() === \"yes\";\n      }\n    });\n\n    setTitle(lines[1]);\n    const tempWordsList = lines.slice(2).filter((word) => word.trim() !== \"\");\n    const uppercaseWordsList = tempWordsList.map((word) => word.toUpperCase());\n    setWords(uppercaseWordsList);\n    setWordsToFind(uppercaseWordsList.length);\n\n    // Check if any word is longer than the grid size\n    const isAnyWordTooLong = uppercaseWordsList.some(\n      (word) => word.length > sizeChoice\n    );\n\n    if (isAnyWordTooLong || sizeChoice > 20 || sizeChoice < 5) {\n      setFailed(true);\n      return;\n    }\n\n    let attempts = 0;\n    let success = false;\n    while (attempts < 3 && !success) {\n      const { grid, wordPlacements, usedCoordinates } = generateWordSearch(\n        sizeChoice,\n        uppercaseWordsList,\n        simpleMode\n      );\n\n      if (grid.length !== 0) {\n        setGrid(grid);\n        setWordPlacements(wordPlacements);\n        setUsedCoordinates(usedCoordinates);\n        success = true; // Successfully generated the grid\n      } else {\n        attempts++;\n      }\n    }\n\n    if (!success) {\n      setFailed(true);\n    }\n  }, [text, gridSize]);\n\n  const handleReveal = () => {\n    setRevealWords(true);\n  };\n\n  function isPartOfWord(rowIndex, colIndex) {\n    return usedCoordinates.includes(`${rowIndex}-${colIndex}`);\n  }\n\n  const handleCellClick = (rowIndex, colIndex) => {\n    if (revealWords) {\n      return;\n    }\n    const selectedCell = `${rowIndex}-${colIndex}`;\n    const updatedSelectedLetters = [...selectedLetters];\n\n    if (selectedLetters.length === 2) {\n      updatedSelectedLetters.splice(0, 2);\n    }\n\n    updatedSelectedLetters.push(selectedCell);\n    setSelectedLetters(updatedSelectedLetters);\n\n    if (updatedSelectedLetters.length === 2) {\n      checkSelectedWord(updatedSelectedLetters);\n    }\n  };\n\n  const markWordAsFound = (word) => {\n    setFoundWords([...foundWords, word]);\n    setSelectedLetters([]);\n    setWordsToFind((prevCount) => prevCount - 1);\n  };\n\n  const checkSelectedWord = (selectedCells) => {\n    const [startCell, endCell] = selectedCells;\n    const [selectedStartRow, selectedStartCol] = startCell\n      .split(\"-\")\n      .map(Number);\n    const [selectedEndRow, selectedEndCol] = endCell.split(\"-\").map(Number);\n\n    for (const { word, startRow, startCol, direction } of wordPlacements) {\n      const { dx, dy } = direction;\n      const wordLength = word.length;\n\n      if (\n        selectedStartRow === startRow &&\n        selectedStartCol === startCol &&\n        selectedEndRow === startRow + (wordLength - 1) * dy &&\n        selectedEndCol === startCol + (wordLength - 1) * dx\n      ) {\n        markWordAsFound(word);\n        return;\n      }\n    }\n\n    setSelectedLetters([]);\n  };\n\n  function isPartOfFoundWord(rowIndex, colIndex, word) {\n    for (const {\n      word: foundWord,\n      startRow,\n      startCol,\n      direction,\n    } of wordPlacements) {\n      if (foundWord === word) {\n        const { dx, dy } = direction;\n        const wordLength = word.length;\n\n        for (let i = 0; i < wordLength; i++) {\n          if (\n            rowIndex === startRow + i * dy &&\n            colIndex === startCol + i * dx\n          ) {\n            return true;\n          }\n        }\n      }\n    }\n    return false;\n  }\n\n  return failed ? (\n    <>\n      <h1 className={styles.interactiveSubTitle}>{title}</h1>\n      <div className={styles.GameArea}>\n        <p className={styles.instructions}>\n          Failed to create wordsearch: refresh to try again or change the puzzle\n          to use a different grid size.\n        </p>\n      </div>\n    </>\n  ) : (\n    <>\n      <h1 className={styles.interactiveSubTitle}>{title}</h1>\n      {wordsToFind === 0 && words.length > 0 && (\n        <div className={styles.celebration}>😃</div>\n      )}\n      <div className={styles.Container}>\n        <div className={styles.GameArea}>\n          <div\n            className={styles.WordSearchGrid}\n            style={{ gridTemplateColumns: `repeat(${gridSize}, 1fr)` }}\n          >\n            {grid.map((row, rowIndex) => (\n              <div key={rowIndex} className={styles.WordSearchRow}>\n                {row.map((cell, colIndex) => (\n                  <div\n                    key={colIndex}\n                    className={`${styles.WordSearchCell} ${\n                      revealWords && isPartOfWord(rowIndex, colIndex)\n                        ? styles.RevealedCell\n                        : \"\"\n                    } ${\n                      selectedLetters.includes(`${rowIndex}-${colIndex}`)\n                        ? styles.SelectedCell\n                        : \"\"\n                    } ${\n                      foundWords.some((word) =>\n                        isPartOfFoundWord(rowIndex, colIndex, word)\n                      )\n                        ? styles.FoundCell\n                        : \"\"\n                    }`}\n                    onClick={() => handleCellClick(rowIndex, colIndex)}\n                  >\n                    {cell}\n                  </div>\n                ))}\n              </div>\n            ))}\n          </div>\n\n          {!showWords && (\n            <div className={styles.WordList}>\n              <h2>Words to Find:</h2>\n              <ul>\n                <li>{wordsToFind}</li>\n              </ul>\n            </div>\n          )}\n\n          {showWords && (\n            <div className={styles.WordList}>\n              <h2>Words to Find:</h2>\n              <ul>\n                {words.map((word, index) => (\n                  <li\n                    key={index}\n                    className={\n                      foundWords.includes(word) ? styles.FoundWord : \"\"\n                    }\n                  >\n                    {word}\n                  </li>\n                ))}\n              </ul>\n            </div>\n          )}\n        </div>\n        {allowReveal && (\n          <button onClick={handleReveal} className={styles.RevealButton}>\n            Reveal\n          </button>\n        )}\n      </div>\n    </>\n  );\n}\nfunction generateWordSearch(size, words, simpleMode) {\n  const directions = simpleMode\n    ? [\n        { dx: 1, dy: 0 }, // Right\n        { dx: 0, dy: 1 }, // Down\n        { dx: 1, dy: 1 }, // Diagonal down-right\n        { dx: -1, dy: 1 }, // Diagonal up-right\n      ]\n    : [\n        { dx: 1, dy: 0 }, // Right\n        { dx: -1, dy: 0 }, // Left\n        { dx: 0, dy: 1 }, // Down\n        { dx: 0, dy: -1 }, // Up\n        { dx: 1, dy: 1 }, // Diagonal down-right\n        { dx: -1, dy: 1 }, // Diagonal down-left\n        { dx: 1, dy: -1 }, // Diagonal up-right\n        { dx: -1, dy: -1 }, // Diagonal up-left\n      ];\n\n  let grid = Array.from({ length: size }, () => Array(size).fill(\"\"));\n  let wordPlacements = [];\n  let usedCoordinates = [];\n\n  words.forEach((word) => {\n    let isolatedOrOverlapAndIsolated = [];\n    let overlappingButNotIsolated = [];\n    let nonIsolated = [];\n\n    for (let row = 0; row < size; row++) {\n      for (let col = 0; col < size; col++) {\n        directions.forEach((direction) => {\n          const { fits, hasOverlap, isIsolated } = canFitWord(\n            grid,\n            word,\n            row,\n            col,\n            direction,\n            simpleMode\n          );\n          if (fits) {\n            const placement = { word, startRow: row, startCol: col, direction };\n            if (isIsolated) {\n              isolatedOrOverlapAndIsolated.push(placement);\n              if (hasOverlap) {\n                isolatedOrOverlapAndIsolated.push(placement);\n                isolatedOrOverlapAndIsolated.push(placement);\n                isolatedOrOverlapAndIsolated.push(placement);\n                isolatedOrOverlapAndIsolated.push(placement); // Add quad to increase likelihood of selection\n              }\n            } else if (hasOverlap) {\n              overlappingButNotIsolated.push(placement);\n            } else {\n              nonIsolated.push(placement);\n            }\n          }\n        });\n      }\n    }\n\n    // Selection logic\n    let selectedPossibilities =\n      isolatedOrOverlapAndIsolated.length > 0\n        ? isolatedOrOverlapAndIsolated\n        : overlappingButNotIsolated.length > 0\n        ? overlappingButNotIsolated\n        : nonIsolated;\n\n    if (selectedPossibilities.length > 0) {\n      const selectedPlacement =\n        selectedPossibilities[\n          Math.floor(Math.random() * selectedPossibilities.length)\n        ];\n      fitWord(\n        grid,\n        selectedPlacement.word,\n        selectedPlacement.startRow,\n        selectedPlacement.startCol,\n        selectedPlacement.direction\n      );\n      wordPlacements.push(selectedPlacement);\n      // Update usedCoordinates based on the selected placement\n      for (let i = 0; i < word.length; i++) {\n        const row =\n          selectedPlacement.startRow + i * selectedPlacement.direction.dy;\n        const col =\n          selectedPlacement.startCol + i * selectedPlacement.direction.dx;\n        usedCoordinates.push(`${row}-${col}`);\n      }\n    } else {\n      // Returning early with failure state if no placement is possible for a word\n      return { grid: [], wordPlacements: [], usedCoordinates: [] };\n    }\n  });\n\n  // Fill in remaining letters\n  for (let row = 0; row < size; row++) {\n    for (let col = 0; col < size; col++) {\n      if (grid[row][col] === \"\") {\n        grid[row][col] = String.fromCharCode(\n          Math.floor(Math.random() * 26) + 65\n        );\n      }\n    }\n  }\n\n  return { grid, wordPlacements, usedCoordinates };\n}\n\nfunction canFitWord(grid, word, startRow, startCol, direction, noOverlap) {\n  let hasOverlap = false;\n  let isIsolated = true;\n  // Make a deep copy of the grid\n  let gridCopy = grid.map((row) => row.slice());\n\n  for (let i = 0; i < word.length; i++) {\n    const row = startRow + i * direction.dy;\n    const col = startCol + i * direction.dx;\n\n    if (row < 0 || row >= grid.length || col < 0 || col >= grid[0].length) {\n      return { fits: false, hasOverlap: false, isIsolated: false };\n    }\n\n    if (grid[row][col] !== \"\" && grid[row][col] !== word[i]) {\n      return { fits: false, hasOverlap: false, isIsolated: false };\n    }\n\n    if (grid[row][col] === word[i]) {\n      hasOverlap = true;\n      if (noOverlap) {\n        return { fits: false, hasOverlap: true, isIsolated: false };\n      }\n      // Set the overlap point and its adjacent squares to empty in the copy\n      setEmptyInGridCopy(gridCopy, row, col);\n    }\n  }\n\n  // Perform the isolation check on the modified grid copy\n  isIsolated = checkIsolated(\n    gridCopy,\n    startRow,\n    startCol,\n    word.length,\n    direction\n  );\n\n  return { fits: true, hasOverlap, isIsolated };\n}\n\nfunction setEmptyInGridCopy(gridCopy, row, col) {\n  const adjacentPositions = [\n    { dx: -1, dy: -1 },\n    { dx: 0, dy: -1 },\n    { dx: 1, dy: -1 },\n    { dx: -1, dy: 0 },\n    { dx: 1, dy: 0 },\n    { dx: -1, dy: 1 },\n    { dx: 0, dy: 1 },\n    { dx: 1, dy: 1 },\n  ];\n  adjacentPositions.forEach(({ dx, dy }) => {\n    const adjRow = row + dy;\n    const adjCol = col + dx;\n    if (\n      adjRow >= 0 &&\n      adjRow < gridCopy.length &&\n      adjCol >= 0 &&\n      adjCol < gridCopy[0].length\n    ) {\n      gridCopy[adjRow][adjCol] = \"\"; // Set adjacent cells to empty\n    }\n  });\n  gridCopy[row][col] = \"\"; // Also set the overlap cell itself to empty\n}\n\nfunction checkIsolated(gridCopy, startRow, startCol, wordLength, direction) {\n  for (let i = 0; i < wordLength; i++) {\n    const row = startRow + i * direction.dy;\n    const col = startCol + i * direction.dx;\n\n    // Simply check adjacent cells in the grid copy for emptiness\n    if (!areAdjacentCellsEmpty(gridCopy, row, col)) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction areAdjacentCellsEmpty(gridCopy, row, col) {\n  const adjacentPositions = [\n    { dx: -1, dy: -1 },\n    { dx: 0, dy: -1 },\n    { dx: 1, dy: -1 },\n    { dx: -1, dy: 0 },\n    { dx: 1, dy: 0 },\n    { dx: -1, dy: 1 },\n    { dx: 0, dy: 1 },\n    { dx: 1, dy: 1 },\n  ];\n  for (const { dx, dy } of adjacentPositions) {\n    const adjRow = row + dy;\n    const adjCol = col + dx;\n    if (\n      adjRow >= 0 &&\n      adjRow < gridCopy.length &&\n      adjCol >= 0 &&\n      adjCol < gridCopy[0].length\n    ) {\n      if (gridCopy[adjRow][adjCol] !== \"\") {\n        return false; // Found a non-empty adjacent cell\n      }\n    }\n  }\n  return true; // All adjacent cells are empty\n}\n\nconst fitWord = (grid, word, startRow, startCol, direction) => {\n  for (let i = 0; i < word.length; i++) {\n    const row = startRow + i * direction.dy;\n    const col = startCol + i * direction.dx;\n    grid[row][col] = word[i];\n  }\n};\n\nexport default WordSearch;\n"],"names":["generateWordSearch","size","words","simpleMode","directions","dx","dy","grid","Array","from","length","fill","wordPlacements","usedCoordinates","forEach","word","isolatedOrOverlapAndIsolated","overlappingButNotIsolated","nonIsolated","row","col","direction","fits","hasOverlap","isIsolated","canFitWord","placement","startRow","startCol","push","selectedPossibilities","selectedPlacement","Math","floor","random","fitWord","i","concat","String","fromCharCode","noOverlap","gridCopy","map","slice","setEmptyInGridCopy","wordLength","areAdjacentCellsEmpty","checkIsolated","_ref2","adjRow","adjCol","adjacentPositions","_ref","text","gridSize","setGridSize","useState","showWords","setShowWords","title","setTitle","setWords","setGrid","revealWords","setRevealWords","allowReveal","setallowReveal","setWordPlacements","setUsedCoordinates","selectedLetters","setSelectedLetters","foundWords","setFoundWords","wordsToFind","setWordsToFind","failed","setFailed","isPartOfWord","rowIndex","colIndex","includes","useEffect","lines","split","options","sizeChoice","showChoice","revealChoice","option","key","value","trim","toLowerCase","parseInt","uppercaseWordsList","filter","toUpperCase","some","attempts","success","markWordAsFound","prevCount","checkSelectedWord","selectedCells","startCell","endCell","selectedStartRow","selectedStartCol","Number","selectedEndRow","selectedEndCol","_jsxs","_Fragment","children","_jsx","className","styles","interactiveSubTitle","GameArea","instructions","celebration","Container","WordSearchGrid","style","gridTemplateColumns","WordSearchRow","cell","WordSearchCell","RevealedCell","SelectedCell","foundWord","isPartOfFoundWord","FoundCell","onClick","handleCellClick","selectedCell","updatedSelectedLetters","splice","WordList","index","FoundWord","handleReveal","RevealButton"],"sourceRoot":""}