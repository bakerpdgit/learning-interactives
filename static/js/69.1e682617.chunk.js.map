{"version":3,"file":"static/js/69.1e682617.chunk.js","mappings":"0KACA,SAAgB,sBAAwB,yCAAyC,kBAAoB,qCAAqC,cAAgB,iCAAiC,SAAW,4BAA4B,oBAAsB,uCAAuC,IAAM,wB,aCIrS,MAAMA,EAAe,UAgTrB,QA9SA,SAAkBC,GAAY,IAAX,KAAEC,GAAMD,EACzB,MAAOE,EAAMC,IAAWC,EAAAA,EAAAA,UAAS,KAC1BC,EAAiBC,IAAsBF,EAAAA,EAAAA,WAAS,IAChDG,EAAaC,IAAkBJ,EAAAA,EAAAA,UAAS,CAC7CK,KAAM,KACNC,MAAO,KACPC,OAAQ,EACRC,OAAQ,KAEHC,EAASC,IAAcV,EAAAA,EAAAA,UAAS,OAChCW,EAAoBC,IAAyBZ,EAAAA,EAAAA,UAAS,CAC3Da,MAAO,EACPC,OAAQ,KAGJ,SAAEC,EAAQ,YAAEC,IAAgBC,EAAAA,EAAAA,KAE5BC,GAASC,EAAAA,EAAAA,QAAO,OAEtBC,EAAAA,EAAAA,YAAU,KACR,MAAMC,EAAQxB,EAAKyB,MAAM,MACnBC,EAAWF,EAAMG,MAEvB,GAAIH,EAAMI,OAAS,EAAG,CACpB,MAAMC,EAAUL,EAAMM,KAAI,CAACC,EAAOtB,KAEhC,MAAMuB,EAAI,GAA6B,GAAxBC,KAAKC,MAAMzB,EAAQ,GAC5B0B,EAAI,GAAM1B,EAAQ,EAAK,GAE7B,MAAO,CACLuB,IACAG,IACAJ,QACAK,OAAQJ,EACRK,OAAQF,EAAI,GACb,IAGHjC,EAAQ2B,EACV,CAEAhB,EACEa,IAAaA,EAASY,SAASxC,GAAgB4B,EAAWR,EAC3D,GACA,CAAClB,EAAMkB,KAEVK,EAAAA,EAAAA,YAAU,KAIR,MAAMgB,EAAYC,YAAW,KACvBnB,EAAOoB,UACT1B,EAAsB,CACpBC,MAAOK,EAAOoB,QAAQC,YACtBzB,OAAQI,EAAOoB,QAAQE,eAGzBzC,GAAS0C,GACAA,EAAYd,KAAKe,GAGpBA,EAAIb,EAAIX,EAAOoB,QAAQC,aACvBG,EAAIV,EAAId,EAAOoB,QAAQE,aAGhB,IAAKE,EAAKb,EAAG,IAAKG,EAAG,IAAKC,OAAQ,IAAKC,OAAQ,IAEjDQ,MAGb,GACC,KAEH,MAAO,IAAMC,aAAaP,EAAU,GACnC,CAAC3B,KAEJW,EAAAA,EAAAA,YAAU,KACR,MAAMwB,EAAQP,YAAW,KACvBnC,GAAmB,EAAM,GACxB,KACH,MAAO,IAAMyC,aAAaC,EAAM,GAC/B,KAEHxB,EAAAA,EAAAA,YAAU,KACR,MAAMyB,EAAeA,KACnB,IACG3B,EAAOoB,SACqB,IAA7B3B,EAAmBE,OACW,IAA9BF,EAAmBG,OAEnB,OAIF,MAAMgC,EACJ5B,EAAOoB,QAAQC,YAAc5B,EAAmBE,MAC5CkC,EACJ7B,EAAOoB,QAAQE,aAAe7B,EAAmBG,OAEnD,IAAIkC,EAAelD,EAAK6B,KAAKe,IAEpB,IACFA,EACHb,EAAGa,EAAIb,EAAIiB,EACXd,EAAGU,EAAIV,EAAIe,EACXd,OAAQS,EAAIT,OAASa,EACrBZ,OAAQQ,EAAIR,OAASa,MAIzBC,EAAeA,EAAarB,KAAKe,GAG7BA,EAAIb,EAAIX,EAAOoB,QAAQC,aACvBG,EAAIV,EAAId,EAAOoB,QAAQE,aAGhB,IAAKE,EAAKb,EAAG,IAAKG,EAAG,IAAKC,OAAQ,IAAKC,OAAQ,IAEjDQ,IAGT3C,EAAQiD,GACJ9B,EAAOoB,SACT1B,EAAsB,CACpBC,MAAOK,EAAOoB,QAAQC,YACtBzB,OAAQI,EAAOoB,QAAQE,cAE3B,EAOF,OAHAS,OAAOC,iBAAiB,SAAUL,GAG3B,KACLI,OAAOE,oBAAoB,SAAUN,EAAa,CACnD,GACA,CAAClC,EAAoBb,IAExB,MAkCMsD,EAAcA,CAACC,EAAG/C,EAAOD,KAC7BgD,EAAEC,aAAaC,QAAQ,aAAc,IAGrC,MAAMC,EAAO1D,EAAKQ,GACZC,EAAkB,QAATF,EAAiBmD,EAAK3B,EAAI2B,EAAKvB,OACxCzB,EAAkB,QAATH,EAAiBmD,EAAKxB,EAAIwB,EAAKtB,OAE9C9B,EAAe,CAAEC,OAAMC,QAAOC,SAAQC,UAAS,EAsC3CiD,EAAmBC,IACvB1C,EAAY0C,GACZhD,EAAWgD,EAAK,EAGlB,OACEC,EAAAA,EAAAA,KAAAC,EAAAA,SAAA,CAAAC,UACEC,EAAAA,EAAAA,MAAA,OAAKC,UAAWC,EAAOC,sBAAsBJ,SAAA,EAC3CC,EAAAA,EAAAA,MAAA,OACEC,UAAWC,EAAOE,kBAClBC,UAAU,QACVC,WA7CYf,IAClBA,EAAEgB,gBAAgB,EA6CZC,OA1CQjB,IACd,IAAKnC,EAAOoB,SAAiC,OAAtBnC,EAAYG,MAAgB,OAEnD,MAAMiE,EAAOrD,EAAOoB,QAAQkC,wBAC5B,IAAIC,EAAOpB,EAAEqB,QAAUH,EAAKI,KACxBC,EAAOvB,EAAEwB,QAAUN,EAAKO,IAG5B,MAAMC,EAAQN,EAAOtE,EAAYI,OAC3ByE,EAAQJ,EAAOzE,EAAYK,OAEjCT,EACED,EAAK6B,KAAI,CAACe,EAAKpC,IACTA,IAAUH,EAAYG,MAEjB,IACFoC,EACHb,EAAGa,EAAIb,GAA0B,QAArB1B,EAAYE,KAAiB0E,EAAQ,GACjD/C,EAAGU,EAAIV,GAA0B,QAArB7B,EAAYE,KAAiB2E,EAAQ,GACjD/C,OAAQS,EAAIT,OAAS8C,EACrB7C,OAAQQ,EAAIR,OAAS8C,GAGlBtC,KAIXtC,EAAe,CAAEC,KAAM,KAAMC,MAAO,KAAMC,OAAQ,EAAGC,OAAQ,GAAI,EAe5CqD,SAAA,GAEZhE,EAAKsC,SAASxC,IAAiBoB,KAChC4C,EAAAA,EAAAA,KAAA,OACEsB,IAAK/D,EACL6C,UAAWC,EAAOkB,cAClBC,IAAI,YACJC,QAnGM/B,IAChB,IAAKnC,EAAOoB,QAAS,OAErB,MAAMiC,EAAOrD,EAAOoB,QAAQkC,wBAC5B,IAAI3C,EAAIwB,EAAEqB,QAAUH,EAAKI,KACrB3C,EAAIqB,EAAEwB,QAAUN,EAAKO,IAGzB/E,GAASsF,GAAa,IACjBA,EACH,CACExD,EAAGC,KAAKwD,IAAI,EAAGxD,KAAKyD,IAAI1D,EAAG0C,EAAK1D,MAAQ,KACxCmB,EAAGF,KAAKwD,IAAI,EAAGxD,KAAKyD,IAAIvD,EAAGuC,EAAKzD,OAAS,KACzCc,MAAO,GACPK,OAAQJ,EACRK,OAAQF,EAAI,MAEd,EAmFQmC,UAAU,QACVqB,IAAK/E,EACLgF,YAAY,cAIf5F,EAAKsC,SAASxC,KAAkBoB,IAC/B+C,EAAAA,EAAAA,MAAA,OAAAD,SAAA,CAAK,+CAEHF,EAAAA,EAAAA,KAAA,SAAO,KACPA,EAAAA,EAAAA,KAAA,SACEtD,KAAK,OACL0D,UAAWC,EAAO0B,WAClBC,OAAO,UACPC,SAAWC,IACTC,EAAAA,EAAAA,IAAsBD,EAAME,OAAOC,MAAM,GAAIvC,QAMpD3D,EAAK6B,KAAI,CAACe,EAAKpC,KACdwD,EAAAA,EAAAA,MAACmC,EAAAA,SAAc,CAAApC,SAAA,EACbF,EAAAA,EAAAA,KAAA,OAEEI,UAAWC,EAAOtB,IAClBwD,MAAO,CAAEvB,KAAK,GAADwB,OAAKzD,EAAIb,EAAI,GAAE,MAAMiD,IAAI,GAADqB,OAAKzD,EAAIV,EAAI,GAAE,OACpDmC,UAAU,OACVf,YAAcC,GAAMD,EAAYC,EAAG/C,EAAO,OAC1C8F,cAAgB/C,GA7GLgD,EAAChD,EAAG/C,KAC3B+C,EAAEgB,iBACFtE,GAASsF,GAAaA,EAASiB,QAAO,CAACC,EAAGC,IAAMA,IAAMlG,KAAO,EA2G3B+F,CAAiBhD,EAAG/C,GAC1CmG,cAAeA,IAzGFnG,KACzB,MAAMsB,EAAQ8E,OAAO,8BAA+B5G,EAAKQ,GAAOsB,OAClD,OAAVA,GAEF7B,EAAQD,EAAK6B,KAAI,CAACe,EAAK8D,IAAOA,IAAMlG,EAAQ,IAAKoC,EAAKd,SAAUc,IAClE,EAoGiCiE,CAAkBrG,IAAO,OAAA6F,OANlC7F,IAQboC,EAAId,QACH+B,EAAAA,EAAAA,KAAA,OACEI,UAAWC,EAAO4C,SAClBV,MAAO,CACLvB,KAAK,GAADwB,OAAKzD,EAAIT,OAAM,MACnB6C,IAAI,GAADqB,OAAKzD,EAAIR,OAAS,GAAE,OAEzBiC,UAAU,OACVf,YAAcC,GAAMD,EAAYC,EAAG/C,EAAO,SAASuD,SAElDnB,EAAId,UAER,YAAAuE,OAtB8B7F,SA0BpCL,IACC6D,EAAAA,EAAAA,MAAA,OAAKC,UAAWC,EAAO6C,oBAAoBhD,SAAA,EACzCF,EAAAA,EAAAA,KAAA,MAAAE,SAAI,gBACJF,EAAAA,EAAAA,KAAA,KAAAE,SAAG,kHASf,C","sources":["webpack://my-react-app/./src/components/ImagePins.module.css?0275","components/ImagePins.js"],"sourcesContent":["// extracted by mini-css-extract-plugin\nexport default {\"imagePinMaincontainer\":\"ImagePins_imagePinMaincontainer__ve+Rp\",\"imagePinContainer\":\"ImagePins_imagePinContainer__gV26t\",\"imagePinImage\":\"ImagePins_imagePinImage__IpjTM\",\"pinLabel\":\"ImagePins_pinLabel__boY-Q\",\"imagePinInstruction\":\"ImagePins_imagePinInstruction__yX44S\",\"pin\":\"ImagePins_pin__FcmAN\"};","import React, { useState, useRef, useEffect } from \"react\";\nimport { handleImageFileChange } from \"../ImageUploads\";\nimport { useEditContext } from \"../EditContext\";\nimport styles from \"./ImagePins.module.css\";\n\nconst LOCAL_MARKER = \"[local]\";\n\nfunction ImagePins({ text }) {\n  const [pins, setPins] = useState([]);\n  const [showInstruction, setShowInstruction] = useState(true);\n  const [draggedItem, setDraggedItem] = useState({\n    type: null,\n    index: null,\n    startX: 0,\n    startY: 0,\n  });\n  const [imgData, setImgData] = useState(null);\n  const [originalDimensions, setOriginalDimensions] = useState({\n    width: 0,\n    height: 0,\n  });\n\n  const { textData, setTextData } = useEditContext();\n\n  const imgRef = useRef(null);\n\n  useEffect(() => {\n    const lines = text.split(\"\\n\"); // Split the text by new lines\n    const imageUrl = lines.pop(); // The last line is the image URL\n\n    if (lines.length > 0) {\n      const newPins = lines.map((label, index) => {\n        // Calculate x and y positions\n        const x = 50 + Math.floor(index / 5) * 70; // Move 50 pixels right for every new column of 5 labels\n        const y = 50 + (index % 5) * 70; // Place labels 70 pixels apart vertically\n\n        return {\n          x,\n          y,\n          label,\n          labelX: x, // Initial label X\n          labelY: y - 40, // Initial label Y (adjust based on your needs)\n        };\n      });\n\n      setPins(newPins);\n    }\n\n    setImgData(\n      imageUrl && !imageUrl.includes(LOCAL_MARKER) ? imageUrl : textData\n    );\n  }, [text, textData]); // Dependency on `text` prop to re-run if it changes\n\n  useEffect(() => {\n    // Assuming imgRef is a ref to your img element\n\n    // Set a timeout to wait for the image to stabilize\n    const timeoutId = setTimeout(() => {\n      if (imgRef.current) {\n        setOriginalDimensions({\n          width: imgRef.current.offsetWidth,\n          height: imgRef.current.offsetHeight,\n        });\n        // Adjust pins if necessary\n        setPins((currentPins) => {\n          return currentPins.map((pin) => {\n            // Check if the pin is outside the bounds of the image\n            if (\n              pin.x > imgRef.current.offsetWidth ||\n              pin.y > imgRef.current.offsetHeight\n            ) {\n              // Reset position to (100, 100) if outside bounds\n              return { ...pin, x: 100, y: 100, labelX: 100, labelY: 50 }; // Adjust labelY accordingly if needed\n            }\n            return pin; // Return the pin unchanged if it's within bounds\n          });\n        });\n      }\n    }, 1000); // 1 second delay to allow for image dimensions to stabilize\n\n    return () => clearTimeout(timeoutId); // Cleanup the timeout if the component unmounts or if textData changes again before the timeout finishes\n  }, [imgData]); // Dependency array includes textData to re-run this effect when textData changes\n\n  useEffect(() => {\n    const timer = setTimeout(() => {\n      setShowInstruction(false);\n    }, 1000);\n    return () => clearTimeout(timer);\n  }, []);\n\n  useEffect(() => {\n    const handleResize = () => {\n      if (\n        !imgRef.current ||\n        originalDimensions.width === 0 ||\n        originalDimensions.height === 0\n      )\n        return; // Ensure the image ref is available\n\n      // Example: Calculate new scale factors based on image's resized dimensions\n      // This assumes you have some way of determining or storing the original dimensions\n      const scaleFactorWidth =\n        imgRef.current.offsetWidth / originalDimensions.width;\n      const scaleFactorHeight =\n        imgRef.current.offsetHeight / originalDimensions.height;\n\n      let rescaledPins = pins.map((pin) => {\n        // Adjust each pin's position based on the scale factor\n        return {\n          ...pin,\n          x: pin.x * scaleFactorWidth,\n          y: pin.y * scaleFactorHeight,\n          labelX: pin.labelX * scaleFactorWidth,\n          labelY: pin.labelY * scaleFactorHeight,\n        };\n      });\n\n      rescaledPins = rescaledPins.map((pin) => {\n        // Check if the pin is outside the bounds of the image\n        if (\n          pin.x > imgRef.current.offsetWidth ||\n          pin.y > imgRef.current.offsetHeight\n        ) {\n          // Reset position to (100, 100) if outside bounds\n          return { ...pin, x: 100, y: 100, labelX: 100, labelY: 50 }; // Adjust labelY accordingly if needed\n        }\n        return pin; // Return the pin unchanged if it's within bounds\n      });\n\n      setPins(rescaledPins); // Update the state with the new positions\n      if (imgRef.current) {\n        setOriginalDimensions({\n          width: imgRef.current.offsetWidth,\n          height: imgRef.current.offsetHeight,\n        });\n      }\n    };\n\n    // Add resize listener\n    window.addEventListener(\"resize\", handleResize);\n\n    // Cleanup function to remove the listener\n    return () => {\n      window.removeEventListener(\"resize\", handleResize);\n    };\n  }, [originalDimensions, pins]); // Empty dependency array means this runs once on mount and cleanup on unmount\n\n  const placePin = (e) => {\n    if (!imgRef.current) return;\n\n    const rect = imgRef.current.getBoundingClientRect();\n    let x = e.clientX - rect.left;\n    let y = e.clientY - rect.top;\n\n    // Add new pin to the array\n    setPins((prevPins) => [\n      ...prevPins,\n      {\n        x: Math.max(0, Math.min(x, rect.width - 20)),\n        y: Math.max(0, Math.min(y, rect.height - 20)),\n        label: \"\",\n        labelX: x, // Initial Label X (same as pin X initially)\n        labelY: y - 40, // Initial Label Y (slightly above pin Y)\n      },\n    ]);\n  };\n\n  const handleRightClick = (e, index) => {\n    e.preventDefault(); // Prevent the browser context menu from opening\n    setPins((prevPins) => prevPins.filter((_, i) => i !== index)); // Remove the pin at the clicked index\n  };\n\n  const handleDoubleClick = (index) => {\n    const label = prompt(\"Enter a label for this pin:\", pins[index].label);\n    if (label !== null) {\n      // Check if the user didn't press Cancel\n      setPins(pins.map((pin, i) => (i === index ? { ...pin, label } : pin)));\n    }\n  };\n\n  // Adjusted onDragStart to prevent default behavior\n  const onDragStart = (e, index, type) => {\n    e.dataTransfer.setData(\"text/plain\", \"\"); // For Firefox compatibility\n\n    // Determine initial position\n    const item = pins[index];\n    const startX = type === \"pin\" ? item.x : item.labelX;\n    const startY = type === \"pin\" ? item.y : item.labelY;\n\n    setDraggedItem({ type, index, startX, startY });\n  };\n\n  // Moved onDragOver to the image-pin-container\n  const onDragOver = (e) => {\n    e.preventDefault(); // This is crucial for allowing the drop\n  };\n\n  const onDrop = (e) => {\n    if (!imgRef.current || draggedItem.index === null) return;\n\n    const rect = imgRef.current.getBoundingClientRect();\n    let endX = e.clientX - rect.left;\n    let endY = e.clientY - rect.top;\n\n    // Calculate movement vector\n    const moveX = endX - draggedItem.startX;\n    const moveY = endY - draggedItem.startY;\n\n    setPins(\n      pins.map((pin, index) => {\n        if (index === draggedItem.index) {\n          // Apply movement vector to both pin and label\n          return {\n            ...pin,\n            x: pin.x + (draggedItem.type === \"pin\" ? moveX : 0),\n            y: pin.y + (draggedItem.type === \"pin\" ? moveY : 0),\n            labelX: pin.labelX + moveX,\n            labelY: pin.labelY + moveY,\n          };\n        }\n        return pin;\n      })\n    );\n\n    setDraggedItem({ type: null, index: null, startX: 0, startY: 0 }); // Reset after drop\n  };\n\n  const updateImageData = (data) => {\n    setTextData(data);\n    setImgData(data);\n  };\n\n  return (\n    <>\n      <div className={styles.imagePinMaincontainer}>\n        <div\n          className={styles.imagePinContainer}\n          draggable=\"false\" // Prevent the container from being draggable\n          onDragOver={onDragOver}\n          onDrop={onDrop}\n        >\n          {(!text.includes(LOCAL_MARKER) || textData) && (\n            <img\n              ref={imgRef}\n              className={styles.imagePinImage}\n              alt=\"Highlight\"\n              onClick={placePin}\n              draggable=\"false\"\n              src={imgData}\n              crossOrigin=\"anonymous\"\n            />\n          )}\n\n          {text.includes(LOCAL_MARKER) && !textData && (\n            <div>\n              The local image will need to be provided...\n              <br />{\" \"}\n              <input\n                type=\"file\"\n                className={styles.fileUpload}\n                accept=\"image/*\"\n                onChange={(event) =>\n                  handleImageFileChange(event.target.files[0], updateImageData)\n                }\n              />\n            </div>\n          )}\n\n          {pins.map((pin, index) => (\n            <React.Fragment key={`pinlabel-${index}`}>\n              <div\n                key={`pin-${index}`}\n                className={styles.pin}\n                style={{ left: `${pin.x - 10}px`, top: `${pin.y - 10}px` }}\n                draggable=\"true\"\n                onDragStart={(e) => onDragStart(e, index, \"pin\")}\n                onContextMenu={(e) => handleRightClick(e, index)}\n                onDoubleClick={() => handleDoubleClick(index)}\n              ></div>\n              {pin.label && (\n                <div\n                  className={styles.pinLabel}\n                  style={{\n                    left: `${pin.labelX}px`,\n                    top: `${pin.labelY - 10}px`,\n                  }}\n                  draggable=\"true\"\n                  onDragStart={(e) => onDragStart(e, index, \"label\")}\n                >\n                  {pin.label}\n                </div>\n              )}\n            </React.Fragment>\n          ))}\n        </div>\n        {showInstruction && (\n          <div className={styles.imagePinInstruction}>\n            <h1>Image Pins</h1>\n            <p>\n              click to drop pins, right-click to delete pin, double-click to add\n              a label; drag labels to reposition.\n            </p>\n          </div>\n        )}\n      </div>\n    </>\n  );\n}\n\nexport default ImagePins;\n"],"names":["LOCAL_MARKER","_ref","text","pins","setPins","useState","showInstruction","setShowInstruction","draggedItem","setDraggedItem","type","index","startX","startY","imgData","setImgData","originalDimensions","setOriginalDimensions","width","height","textData","setTextData","useEditContext","imgRef","useRef","useEffect","lines","split","imageUrl","pop","length","newPins","map","label","x","Math","floor","y","labelX","labelY","includes","timeoutId","setTimeout","current","offsetWidth","offsetHeight","currentPins","pin","clearTimeout","timer","handleResize","scaleFactorWidth","scaleFactorHeight","rescaledPins","window","addEventListener","removeEventListener","onDragStart","e","dataTransfer","setData","item","updateImageData","data","_jsx","_Fragment","children","_jsxs","className","styles","imagePinMaincontainer","imagePinContainer","draggable","onDragOver","preventDefault","onDrop","rect","getBoundingClientRect","endX","clientX","left","endY","clientY","top","moveX","moveY","ref","imagePinImage","alt","onClick","prevPins","max","min","src","crossOrigin","fileUpload","accept","onChange","event","handleImageFileChange","target","files","React","style","concat","onContextMenu","handleRightClick","filter","_","i","onDoubleClick","prompt","handleDoubleClick","pinLabel","imagePinInstruction"],"sourceRoot":""}