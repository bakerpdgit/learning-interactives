{"version":3,"file":"static/js/521.7a948d1a.chunk.js","mappings":"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","sources":["components/MathComponent.js","components/Tarsia.js"],"sourcesContent":["import { InlineMath } from \"react-katex\";\r\n\r\nfunction parseAndRenderMath(text) {\r\n  const prefix = Math.random().toString(36).substring(2, 10); // Generate an 8-character random string\r\n\r\n  // Split the text based on $$ delimiters\r\n  const segments = text.split(\"$$\");\r\n  const elements = [];\r\n\r\n  segments.forEach((segment, index) => {\r\n    if (index % 2 === 1) {\r\n      // Odd-indexed segments are LaTeX (since they are enclosed between $$ delimiters)\r\n      elements.push(\r\n        <InlineMath key={`MCIM-${prefix}-${index}`} math={segment} />\r\n      );\r\n    } else {\r\n      elements.push(<span key={`MCSP-${prefix}-${index}`}>{segment}</span>);\r\n    }\r\n  });\r\n\r\n  return elements;\r\n}\r\n\r\nconst renderWithNewLines = (text) => {\r\n  return text.replace(/\\\\n/g, \"\\n\");\r\n};\r\n\r\nfunction MathComponent({ text, renderNewLines = false }) {\r\n  if (renderNewLines) {\r\n    text = renderWithNewLines(text);\r\n  }\r\n\r\n  return (\r\n    <div\r\n      style={{\r\n        whiteSpace:\r\n          text.includes(\"\\n\") && renderNewLines ? \"pre-wrap\" : \"normal\",\r\n        marginTop: text.includes(\"$$\") ? \"0.5em\" : \"0\",\r\n      }}\r\n    >\r\n      {parseAndRenderMath(text)}\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default MathComponent;\r\n","import React, {\r\n  useState,\r\n  useImperativeHandle,\r\n  forwardRef,\r\n  useRef,\r\n  useEffect,\r\n} from \"react\";\r\nimport \"./Tarsia.css\";\r\nimport MathComponent from \"./MathComponent.js\";\r\n\r\nconst SquareComponent = forwardRef((props, ref) => {\r\n  const { lb1, lb2, lb3, lb4, isSelected, onSelect, sqSize } = props;\r\n  // eslint-disable-next-line\r\n  const [labels, setLabels] = useState([lb1, lb2, lb3, lb4]);\r\n\r\n  useImperativeHandle(ref, () => ({\r\n    getLabels: () => labels,\r\n    setLabels: (newLabels) => setLabels(newLabels),\r\n    rotateLabels: () => {\r\n      setLabels((prevLabels) => [prevLabels[3], ...prevLabels.slice(0, 3)]);\r\n    },\r\n  }));\r\n\r\n  return (\r\n    <div\r\n      style={{ width: `${sqSize}px`, height: `${sqSize}px` }}\r\n      className={`square ${isSelected ? \"selected\" : \"\"}`}\r\n      onClick={onSelect}\r\n    >\r\n      <div className=\"label top\">\r\n        {\" \"}\r\n        <MathComponent text={labels[0]} renderNewLines={true} />\r\n      </div>\r\n      <div className=\"label right\">\r\n        {\" \"}\r\n        <MathComponent text={labels[1]} renderNewLines={true} />\r\n      </div>\r\n      <div className=\"label bottom\">\r\n        {\" \"}\r\n        <MathComponent text={labels[2]} renderNewLines={true} />\r\n      </div>\r\n      <div className=\"label left\">\r\n        {\" \"}\r\n        <MathComponent text={labels[3]} renderNewLines={true} />\r\n      </div>\r\n      <button\r\n        className=\"rotate-button\"\r\n        style={{ fontSize: \"1.5em\" }}\r\n        onClick={(event) => {\r\n          event.stopPropagation();\r\n          setLabels((prev) => [prev[3], ...prev.slice(0, 3)]);\r\n        }}\r\n      >\r\n        ðŸ”„\r\n      </button>\r\n    </div>\r\n  );\r\n});\r\n\r\nfunction findAdjacent(squareIndex, labelIndex, gridDimension) {\r\n  const row = Math.floor(squareIndex / gridDimension);\r\n  const col = squareIndex % gridDimension;\r\n\r\n  let adjacentRow = row;\r\n  let adjacentCol = col;\r\n  let adjacentLabelIndex;\r\n\r\n  switch (labelIndex) {\r\n    case 0: // Top\r\n      adjacentRow = row - 1;\r\n      adjacentLabelIndex = 2; // Bottom label of the square above\r\n      break;\r\n    case 1: // Right\r\n      adjacentCol = col + 1;\r\n      adjacentLabelIndex = 3; // Left label of the square on the right\r\n      break;\r\n    case 2: // Bottom\r\n      adjacentRow = row + 1;\r\n      adjacentLabelIndex = 0; // Top label of the square below\r\n      break;\r\n    case 3: // Left\r\n      adjacentCol = col - 1;\r\n      adjacentLabelIndex = 1; // Right label of the square on the left\r\n      break;\r\n    default:\r\n      return null;\r\n  }\r\n\r\n  if (\r\n    adjacentRow >= 0 &&\r\n    adjacentRow < gridDimension &&\r\n    adjacentCol >= 0 &&\r\n    adjacentCol < gridDimension\r\n  ) {\r\n    const adjacentSquareIndex = adjacentRow * gridDimension + adjacentCol;\r\n    return { squareIndex: adjacentSquareIndex, labelIndex: adjacentLabelIndex };\r\n  } else {\r\n    return null; // Indicates the label is facing outwards\r\n  }\r\n}\r\n\r\nfunction checkSolution(squares, originalPairs, gridDimension) {\r\n  for (let squareIndex = 0; squareIndex < squares.length; squareIndex++) {\r\n    const square = squares[squareIndex];\r\n\r\n    for (let labelIndex = 0; labelIndex < 4; labelIndex++) {\r\n      const label = square.labels[labelIndex];\r\n\r\n      // Skip empty labels\r\n      if (label === \"\") continue;\r\n\r\n      // Find the adjacent square and label index\r\n      const adjacent = findAdjacent(squareIndex, labelIndex, gridDimension);\r\n\r\n      // If there's no adjacent square (label is facing outwards), puzzle can't be correct\r\n      if (adjacent === null) return false;\r\n\r\n      // Get the label from the adjacent square\r\n      const adjacentLabel =\r\n        squares[adjacent.squareIndex].labels[adjacent.labelIndex];\r\n\r\n      // If the adjacent label is empty, puzzle can't be correct\r\n      if (adjacentLabel === \"\") return false;\r\n\r\n      // Check if the pair exists in the original pairs list\r\n      const pair = `${label}:${adjacentLabel}`;\r\n      const reversedPair = `${adjacentLabel}:${label}`;\r\n\r\n      if (\r\n        !originalPairs.includes(pair) &&\r\n        !originalPairs.includes(reversedPair)\r\n      ) {\r\n        return false;\r\n      }\r\n    }\r\n  }\r\n\r\n  // If we've made it through all the checks, the puzzle is correct\r\n  return true;\r\n}\r\n\r\nconst SquareGrid = ({ components, originalPairs, gridDimension, sqSize }) => {\r\n  const [selected, setSelected] = useState(null);\r\n  const [firstSelected, setFirstSelected] = useState(null); // First selected square for swapping\r\n  const squareRefs = useRef([]);\r\n  const [message, setMessage] = useState(null);\r\n  const [fontSize, setFontSize] = useState(1); // Default font size\r\n  const [isCorrect, setIsCorrect] = useState(false);\r\n\r\n  const increaseFontSize = () => setFontSize((prevSize) => prevSize + 0.1);\r\n  const decreaseFontSize = () =>\r\n    setFontSize((prevSize) => Math.max(0.4, prevSize - 0.1));\r\n\r\n  const handleCheckSolution = () => {\r\n    const result = checkPuzzle();\r\n    if (result) {\r\n      setIsCorrect(true);\r\n      setMessage(\"Well Done!\");\r\n    } else {\r\n      setIsCorrect(false);\r\n      setMessage(\"Not Yet!\");\r\n    }\r\n\r\n    // Clear the message after 2 seconds\r\n    setTimeout(() => setMessage(null), 2000);\r\n  };\r\n\r\n  const checkPuzzle = () => {\r\n    const allSquares = squareRefs.current.map((ref) => ({\r\n      labels: ref.getLabels(),\r\n    }));\r\n    return checkSolution(allSquares, originalPairs, gridDimension);\r\n  };\r\n\r\n  const handleSelect = (index) => {\r\n    if (firstSelected !== null) {\r\n      // Swap labels between firstSelected and currently selected square\r\n      const firstLabels = squareRefs.current[firstSelected].getLabels();\r\n      const secondLabels = squareRefs.current[index].getLabels();\r\n      squareRefs.current[firstSelected].setLabels(secondLabels);\r\n      squareRefs.current[index].setLabels(firstLabels);\r\n\r\n      // Reset firstSelected and selected\r\n      setFirstSelected(null);\r\n      setSelected(null);\r\n\r\n      checkPuzzle();\r\n    } else {\r\n      setFirstSelected(index);\r\n      setSelected(index);\r\n    }\r\n  };\r\n\r\n  return (\r\n    <>\r\n      <div\r\n        style={{ fontSize: `${fontSize}em` }}\r\n        className={`grid-container ${\r\n          gridDimension === 3 ? \"three-by-three\" : \"four-by-four\"\r\n        }`}\r\n      >\r\n        {components.map((props, index) => (\r\n          <div key={index} className=\"grid-item\">\r\n            <SquareComponent\r\n              ref={(el) => (squareRefs.current[index] = el)}\r\n              {...props}\r\n              isSelected={selected === index}\r\n              onSelect={() => handleSelect(index)}\r\n              checkPuzzle={checkPuzzle}\r\n              sqSize={sqSize}\r\n            />\r\n          </div>\r\n        ))}\r\n      </div>\r\n      {message && (\r\n        <div className={`message ${isCorrect ? \"isCorrect\" : \"isIncorrect\"}`}>\r\n          {message}\r\n        </div>\r\n      )}\r\n      <span>\r\n        <button onClick={handleCheckSolution}>Check Solution</button>\r\n        <button onClick={increaseFontSize}>+</button>\r\n        <button onClick={decreaseFontSize}>-</button>\r\n      </span>\r\n      {isCorrect && <div className=\"celebration\">ðŸŽ‰</div>}\r\n    </>\r\n  );\r\n};\r\n\r\nconst GameArea = ({ text }) => {\r\n  const gameAreaRef = useRef(null); // Step 2: Setup ref for the game area\r\n  const [sqSize, setSqSize] = useState(250); // Default size, will update dynamically\r\n\r\n  let lines = text.split(\"\\n\");\r\n  const originalPairs = lines.map((line) => line.replace(\"\\n\", \"\"));\r\n  // Shuffle and swap function\r\n  function shuffleArray(array) {\r\n    for (let i = array.length - 1; i > 0; i--) {\r\n      const j = Math.floor(Math.random() * (i + 1));\r\n      [array[i], array[j]] = [array[j], array[i]];\r\n    }\r\n    return array;\r\n  }\r\n\r\n  // Function to rotate labels in a grid object\r\n  const rotateLabels = (gridObj) => {\r\n    const keys = [\"lb1\", \"lb2\", \"lb3\", \"lb4\"];\r\n    const numRotations = Math.floor(Math.random() * 4); // Random number between 0 and 3\r\n\r\n    for (let i = 0; i < numRotations; i++) {\r\n      const temp = gridObj[keys[3]];\r\n      for (let j = 3; j > 0; j--) {\r\n        gridObj[keys[j]] = gridObj[keys[j - 1]];\r\n      }\r\n      gridObj[keys[0]] = temp;\r\n    }\r\n\r\n    return gridObj;\r\n  };\r\n\r\n  // Randomly swap questions and answers and shuffle the order\r\n  lines = shuffleArray(\r\n    lines.map((line) => {\r\n      const [q, a] = line.split(\":\");\r\n      return Math.random() > 0.5 ? `${a}:${q}` : line;\r\n    })\r\n  );\r\n\r\n  // BUILD PUZZLE: Step 1: Determine Grid Dimension\r\n  const pairsCount = lines.length;\r\n  let gridDimension;\r\n\r\n  if (pairsCount <= 12) {\r\n    gridDimension = 3;\r\n  } else if (pairsCount <= 24) {\r\n    gridDimension = 4;\r\n  } else {\r\n    console.error(\"Too many question-answer pairs!\");\r\n  }\r\n\r\n  // Step 2: Initialize 2D Grid\r\n  const grid = Array.from({ length: gridDimension }, () =>\r\n    Array.from({ length: gridDimension }, () => ({\r\n      lb1: \"\",\r\n      lb2: \"\",\r\n      lb3: \"\",\r\n      lb4: \"\",\r\n    }))\r\n  );\r\n\r\n  // Step 3: Populate Labels\r\n  let counter = 0;\r\n  const qaPairs = lines.map((line) => {\r\n    const [question, answer] = line.split(\":\");\r\n    return { question, answer };\r\n  });\r\n\r\n  for (let row = 0; row < gridDimension; row++) {\r\n    for (let col = 0; col < gridDimension - 1; col++) {\r\n      if (counter < pairsCount) {\r\n        grid[row][col].lb2 = qaPairs[counter].question;\r\n        grid[row][col + 1].lb4 = qaPairs[counter].answer;\r\n        counter++;\r\n      }\r\n    }\r\n    if (row < gridDimension - 1) {\r\n      for (let col = 0; col < gridDimension; col++) {\r\n        if (counter < pairsCount) {\r\n          grid[row][col].lb3 = qaPairs[counter].question;\r\n          grid[row + 1][col].lb1 = qaPairs[counter].answer;\r\n          counter++;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // Step 4: Flatten 2D Grid\r\n  const components = shuffleArray(grid.flat());\r\n\r\n  // Step 5: apply a random number of rotations to each:\r\n  const rotatedComponents = components.map(rotateLabels);\r\n\r\n  useEffect(() => {\r\n    const calculateSquareSize = () => {\r\n      if (gameAreaRef.current) {\r\n        const gameAreaHeight = gameAreaRef.current.clientHeight; // Get current height of the game area\r\n        const spaceForButtons = 70; // Adjust based on your actual space for buttons, in pixels\r\n        const gridSize = gridDimension; // This comes from your existing logic\r\n        const size = (gameAreaHeight - spaceForButtons) / gridSize;\r\n        setSqSize(size); // Update state with the calculated size\r\n      }\r\n    };\r\n\r\n    calculateSquareSize(); // Calculate initially\r\n\r\n    window.addEventListener(\"resize\", calculateSquareSize); // Recalculate on resize\r\n    return () => window.removeEventListener(\"resize\", calculateSquareSize); // Cleanup listener\r\n  }, [gridDimension]); // Effect dependencies\r\n\r\n  // Pass 'components' to SquareGrid\r\n\r\n  return (\r\n    <div className=\"gameArea\" ref={gameAreaRef}>\r\n      <SquareGrid\r\n        components={rotatedComponents}\r\n        originalPairs={originalPairs}\r\n        gridDimension={gridDimension}\r\n        sqSize={sqSize}\r\n      />\r\n    </div>\r\n  );\r\n};\r\n\r\nfunction Tarsia({ text }) {\r\n  return (\r\n    <>\r\n      <GameArea text={text} />\r\n    </>\r\n  );\r\n}\r\n\r\nexport default Tarsia;\r\n"],"names":["parseAndRenderMath","text","prefix","Math","random","toString","substring","segments","split","elements","forEach","segment","index","push","_jsx","InlineMath","math","concat","children","_ref","renderNewLines","replace","renderWithNewLines","style","whiteSpace","includes","marginTop","SquareComponent","forwardRef","props","ref","lb1","lb2","lb3","lb4","isSelected","onSelect","sqSize","labels","setLabels","useState","useImperativeHandle","getLabels","newLabels","rotateLabels","prevLabels","slice","_jsxs","width","height","className","onClick","MathComponent","fontSize","event","stopPropagation","prev","findAdjacent","squareIndex","labelIndex","gridDimension","row","floor","col","adjacentLabelIndex","adjacentRow","adjacentCol","SquareGrid","components","originalPairs","selected","setSelected","firstSelected","setFirstSelected","squareRefs","useRef","message","setMessage","setFontSize","isCorrect","setIsCorrect","checkPuzzle","squares","length","square","label","adjacent","adjacentLabel","pair","reversedPair","checkSolution","current","map","_Fragment","el","firstLabels","secondLabels","handleSelect","handleCheckSolution","setTimeout","increaseFontSize","prevSize","decreaseFontSize","max","GameArea","_ref2","gameAreaRef","setSqSize","lines","line","shuffleArray","array","i","j","q","a","pairsCount","console","error","grid","Array","from","counter","qaPairs","question","answer","rotatedComponents","flat","gridObj","keys","numRotations","temp","useEffect","calculateSquareSize","gameAreaHeight","clientHeight","window","addEventListener","removeEventListener","_ref3"],"sourceRoot":""}