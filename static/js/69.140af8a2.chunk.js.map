{"version":3,"file":"static/js/69.140af8a2.chunk.js","mappings":"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","sources":["webpack://my-react-app/./src/components/ImagePins.module.css?0275","components/ImagePins.js"],"sourcesContent":["// extracted by mini-css-extract-plugin\nexport default {\"imagePinMaincontainer\":\"ImagePins_imagePinMaincontainer__ve+Rp\",\"imagePinContainer\":\"ImagePins_imagePinContainer__gV26t\",\"imagePinImage\":\"ImagePins_imagePinImage__IpjTM\",\"pinLabel\":\"ImagePins_pinLabel__boY-Q\",\"correctLabel\":\"ImagePins_correctLabel__qIafK\",\"errorLabel\":\"ImagePins_errorLabel__8NLFJ\",\"hiddenLabelsContainer\":\"ImagePins_hiddenLabelsContainer__E33Kt\",\"hiddenLabel\":\"ImagePins_hiddenLabel__j-Yd4\",\"imagePinInstruction\":\"ImagePins_imagePinInstruction__yX44S\",\"pin\":\"ImagePins_pin__FcmAN\",\"pinDraggable\":\"ImagePins_pinDraggable__-W5-y\",\"celebration\":\"ImagePins_celebration__eLfSQ\",\"flyAcross\":\"ImagePins_flyAcross__HgWSj\"};","import React, { useState, useRef, useEffect } from \"react\";\nimport { handleImageFileChange } from \"../ImageUploads\";\nimport { useEditContext } from \"../EditContext\";\nimport styles from \"./ImagePins.module.css\";\nimport { LOCAL_MARKER } from \"./TextInput\";\n\nfunction ImagePins({ text }) {\n  const [pins, setPins] = useState([]);\n  const [hiddenCount, setHiddenCount] = useState(0);\n  const [hiddenLabels, setHiddenLabels] = useState([]); // Array of hidden labels [label1, label2, ...\n  const [showInstruction, setShowInstruction] = useState(true);\n  const [showCelebration, setShowCelebration] = useState(false);\n\n  const [draggedItem, setDraggedItem] = useState({\n    type: null,\n    index: null,\n    startX: 0,\n    startY: 0,\n  });\n\n  const [imgData, setImgData] = useState(null);\n\n  const [originalDimensions, setOriginalDimensions] = useState({\n    width: 0,\n    height: 0,\n  });\n\n  const { textData, imageData, setImageData } = useEditContext();\n\n  const imgRef = useRef(null);\n\n  useEffect(() => {\n    const lines = text.split(\"\\n\"); // Split the text by new lines\n    const optionsLine = lines[0].startsWith(\"OPTIONS:\") ? lines.shift() : null;\n    const imageUrl = lines.pop(); // The last line is the image URL\n\n    let showHiddenLabels = false;\n    if (optionsLine) {\n      const options = optionsLine.substring(8).split(\";\");\n      options.forEach((option) => {\n        const [key, value] = option.split(\"=\");\n        if (key === \"show\" && value === \"yes\") {\n          showHiddenLabels = true;\n        }\n      });\n    }\n\n    const hiddenLabels = [];\n\n    if (lines.length > 0) {\n      let hiddenPinCount = 0;\n\n      const newPins = lines.map((label, index) => {\n        const coordinateMatch = label.match(/\\((\\d+(\\.\\d+)?),(\\d+(\\.\\d+)?)\\)$/);\n        if (coordinateMatch) {\n          hiddenPinCount++;\n          label = label.replace(coordinateMatch[0], \"\"); // Remove the coordinates from the label\n          hiddenLabels.push(label);\n          const xPercent = parseFloat(coordinateMatch[1]);\n          const yPercent = parseFloat(coordinateMatch[3]);\n          const x = (xPercent / 100) * originalDimensions.width;\n          const y = (yPercent / 100) * originalDimensions.height;\n          return {\n            x,\n            y,\n            label: \"\",\n            labelX: x,\n            labelY: y - 40,\n            hidden: true, // Mark the label as hidden\n            labelAnswer: label,\n            provided: true, // given in setup so cannot be deleted\n          };\n        } else {\n          const adjustedIndex = index - hiddenPinCount;\n          const x = 50 + Math.floor(adjustedIndex / 5) * 70; // Move 50 pixels right for every new column of 5 labels\n          const y = 50 + (adjustedIndex % 5) * 70; // Place labels 70 pixels apart vertically\n          return {\n            x,\n            y,\n            label,\n            labelX: x,\n            labelY: y - 40,\n            hidden: false, // Visible label\n            provided: true,\n          };\n        }\n      });\n\n      setPins(newPins);\n      setHiddenCount(hiddenPinCount);\n\n      if (showHiddenLabels) {\n        // randomly shuffle the hidden labels\n        setHiddenLabels(hiddenLabels.sort(() => Math.random() - 0.5));\n      }\n    }\n\n    setImgData(\n      imageUrl && !imageUrl.includes(LOCAL_MARKER) ? imageUrl : imageData\n    );\n  }, [\n    text,\n    textData,\n    imageData,\n    originalDimensions.width,\n    originalDimensions.height,\n  ]); // Dependency array includes textData to re-run this effect when textData changes\n\n  useEffect(() => {\n    // Assuming imgRef is a ref to your img element\n\n    // Set a timeout to wait for the image to stabilize\n    const timeoutId = setTimeout(() => {\n      if (imgRef.current) {\n        setOriginalDimensions({\n          width: imgRef.current.offsetWidth,\n          height: imgRef.current.offsetHeight,\n        });\n        // Adjust pins if necessary\n        setPins((currentPins) => {\n          return currentPins.map((pin) => {\n            // Check if the pin is outside the bounds of the image\n            if (\n              pin.x > imgRef.current.offsetWidth ||\n              pin.y > imgRef.current.offsetHeight\n            ) {\n              // Reset position to (100, 100) if outside bounds\n              return { ...pin, x: 100, y: 100, labelX: 100, labelY: 50 }; // Adjust labelY accordingly if needed\n            }\n            return pin; // Return the pin unchanged if it's within bounds\n          });\n        });\n      }\n    }, 1000); // 1 second delay to allow for image dimensions to stabilize\n\n    return () => clearTimeout(timeoutId); // Cleanup the timeout if the component unmounts or if textData changes again before the timeout finishes\n  }, [imgData]); // Dependency array includes textData to re-run this effect when textData changes\n\n  useEffect(() => {\n    const timer = setTimeout(() => {\n      setShowInstruction(false);\n    }, 1000);\n    return () => clearTimeout(timer);\n  }, []);\n\n  useEffect(() => {\n    const handleResize = () => {\n      if (\n        !imgRef.current ||\n        originalDimensions.width === 0 ||\n        originalDimensions.height === 0\n      )\n        return; // Ensure the image ref is available\n\n      // Example: Calculate new scale factors based on image's resized dimensions\n      // This assumes you have some way of determining or storing the original dimensions\n      const scaleFactorWidth =\n        imgRef.current.offsetWidth / originalDimensions.width;\n      const scaleFactorHeight =\n        imgRef.current.offsetHeight / originalDimensions.height;\n\n      let rescaledPins = pins.map((pin) => {\n        // Adjust each pin's position based on the scale factor\n        return {\n          ...pin,\n          x: pin.x * scaleFactorWidth,\n          y: pin.y * scaleFactorHeight,\n          labelX: pin.labelX * scaleFactorWidth,\n          labelY: pin.labelY * scaleFactorHeight,\n        };\n      });\n\n      rescaledPins = rescaledPins.map((pin) => {\n        // Check if the pin is outside the bounds of the image\n        if (\n          pin.x > imgRef.current.offsetWidth ||\n          pin.y > imgRef.current.offsetHeight\n        ) {\n          // Reset position to (100, 100) if outside bounds\n          return { ...pin, x: 100, y: 100, labelX: 100, labelY: 50 }; // Adjust labelY accordingly if needed\n        }\n        return pin; // Return the pin unchanged if it's within bounds\n      });\n\n      setPins(rescaledPins); // Update the state with the new positions\n      if (imgRef.current) {\n        setOriginalDimensions({\n          width: imgRef.current.offsetWidth,\n          height: imgRef.current.offsetHeight,\n        });\n      }\n    };\n\n    // Add resize listener\n    window.addEventListener(\"resize\", handleResize);\n\n    // Cleanup function to remove the listener\n    return () => {\n      window.removeEventListener(\"resize\", handleResize);\n    };\n  }, [originalDimensions, pins]); // Empty dependency array means this runs once on mount and cleanup on unmount\n\n  const placePin = (e) => {\n    if (!imgRef.current) return;\n\n    const rect = imgRef.current.getBoundingClientRect();\n    let x = e.clientX - rect.left;\n    let y = e.clientY - rect.top;\n\n    // Add new pin to the array\n    setPins((prevPins) => [\n      ...prevPins,\n      {\n        x: Math.max(0, Math.min(x, rect.width - 20)),\n        y: Math.max(0, Math.min(y, rect.height - 20)),\n        label: \"\",\n        labelX: x, // Initial Label X (same as pin X initially)\n        labelY: y - 40, // Initial Label Y (slightly above pin Y)\n        provided: false, // can be deleted\n      },\n    ]);\n  };\n\n  const handleRightClick = (e, index) => {\n    e.preventDefault(); // Prevent the browser context menu from opening\n    setPins((prevPins) =>\n      prevPins.filter((pin, i) => i !== index || pin.provided)\n    ); // Remove the pin at the clicked index\n  };\n\n  const handleDoubleClick = (index) => {\n    const inputLabel = prompt(\"Enter a label for this pin:\", pins[index].label);\n    if (inputLabel !== null) {\n      if (pins[index].hidden) {\n        const normalizedInput = inputLabel\n          .trim()\n          .toLowerCase()\n          .replace(/\\s+/g, \"\");\n        const normalizedOriginal = pins[index].labelAnswer\n          .trim()\n          .toLowerCase()\n          .replace(/\\s+/g, \"\");\n\n        if (normalizedInput === normalizedOriginal) {\n          setPins(\n            pins.map((pin, i) =>\n              i === index\n                ? {\n                    ...pin,\n                    label: pins[index].labelAnswer,\n                    hidden: true,\n                  }\n                : pin\n            )\n          );\n          const newHiddenCount = hiddenCount - 1;\n          setHiddenCount(newHiddenCount);\n          if (newHiddenCount === 0) {\n            setShowCelebration(true);\n          }\n        } else {\n          setPins(\n            pins.map((pin, i) =>\n              i === index ? { ...pin, label: \"try again\", error: true } : pin\n            )\n          );\n          setTimeout(() => {\n            setPins(\n              pins.map((pin, i) =>\n                i === index ? { ...pin, label: \"\", error: false } : pin\n              )\n            );\n          }, 1000);\n        }\n      } else {\n        setPins(\n          pins.map((pin, i) =>\n            i === index ? { ...pin, label: inputLabel } : pin\n          )\n        );\n      }\n    }\n  };\n\n  // Adjusted onDragStart to prevent default behavior\n  const onDragStart = (e, index, type) => {\n    e.dataTransfer.setData(\"text/plain\", \"\"); // For Firefox compatibility\n\n    // Determine initial position\n    const item = pins[index];\n    const startX = type === \"pin\" ? item.x : item.labelX;\n    const startY = type === \"pin\" ? item.y : item.labelY;\n\n    setDraggedItem({ type, index, startX, startY });\n  };\n\n  // Moved onDragOver to the image-pin-container\n  const onDragOver = (e) => {\n    e.preventDefault(); // This is crucial for allowing the drop\n  };\n\n  const onDrop = (e) => {\n    if (!imgRef.current || draggedItem.index === null) return;\n\n    const rect = imgRef.current.getBoundingClientRect();\n    let endX = e.clientX - rect.left;\n    let endY = e.clientY - rect.top;\n\n    // Calculate movement vector\n    const moveX = endX - draggedItem.startX;\n    const moveY = endY - draggedItem.startY;\n\n    setPins(\n      pins.map((pin, index) => {\n        if (index === draggedItem.index) {\n          // Apply movement vector to both pin and label\n          return {\n            ...pin,\n            x: pin.x + (draggedItem.type === \"pin\" ? moveX : 0),\n            y: pin.y + (draggedItem.type === \"pin\" ? moveY : 0),\n            labelX: pin.labelX + moveX,\n            labelY: pin.labelY + moveY,\n          };\n        }\n        return pin;\n      })\n    );\n\n    setDraggedItem({ type: null, index: null, startX: 0, startY: 0 }); // Reset after drop\n  };\n\n  const updateImageData = (data) => {\n    setImageData(data);\n    setImgData(data);\n  };\n\n  return (\n    <>\n      <div className={styles.imagePinMaincontainer}>\n        <div\n          className={styles.imagePinContainer}\n          draggable=\"false\" // Prevent the container from being draggable\n          onDragOver={onDragOver}\n          onDrop={onDrop}\n        >\n          {(!text.includes(LOCAL_MARKER) || textData) && (\n            <img\n              ref={imgRef}\n              className={styles.imagePinImage}\n              alt=\"Highlight\"\n              onClick={placePin}\n              draggable=\"false\"\n              src={imgData}\n              crossOrigin=\"anonymous\"\n            />\n          )}\n\n          {text.includes(LOCAL_MARKER) && !textData && (\n            <div>\n              The local image will need to be provided...\n              <br />{\" \"}\n              <input\n                type=\"file\"\n                className={styles.fileUpload}\n                accept=\"image/*\"\n                onChange={(event) =>\n                  handleImageFileChange(event.target.files[0], updateImageData)\n                }\n              />\n            </div>\n          )}\n\n          {pins.map((pin, index) => (\n            <React.Fragment key={`pinlabel-${index}`}>\n              <div\n                key={`pin-${index}`}\n                className={`${styles.pin} ${\n                  !pin.hidden ? styles.pinDraggable : \"\"\n                }`}\n                style={{ left: `${pin.x - 10}px`, top: `${pin.y - 10}px` }}\n                draggable={!pin.hidden}\n                onDragStart={(e) => onDragStart(e, index, \"pin\")}\n                onContextMenu={(e) => handleRightClick(e, index)}\n                onDoubleClick={() => handleDoubleClick(index)}\n              ></div>\n              {pin.label && (\n                <div\n                  className={`${styles.pinLabel} ${\n                    pin.hidden === true ? styles.correctLabel : \"\"\n                  } ${pin.error ? styles.errorLabel : \"\"}`}\n                  style={{\n                    left: `${pin.labelX}px`,\n                    top: `${pin.labelY - 10}px`,\n                  }}\n                  draggable=\"true\"\n                  onDragStart={(e) => onDragStart(e, index, \"label\")}\n                >\n                  {pin.label}\n                </div>\n              )}\n            </React.Fragment>\n          ))}\n        </div>\n        {showInstruction && (\n          <div className={styles.imagePinInstruction}>\n            <h1>Image Pins</h1>\n            <p>\n              click to drop pins, right-click to delete pin, double-click to add\n              a label; drag labels to reposition.\n            </p>\n          </div>\n        )}\n      </div>\n      {hiddenLabels && (\n        <div className={styles.hiddenLabelsContainer}>\n          {hiddenLabels.map((label, index) => (\n            <div key={`hiddenLbl${index}`} className={styles.hiddenLabel}>\n              {label}\n            </div>\n          ))}\n        </div>\n      )}\n      {showCelebration && <div className={styles.celebration}>🎺</div>}\n    </>\n  );\n}\n\nexport default ImagePins;\n"],"names":["_ref","text","pins","setPins","useState","hiddenCount","setHiddenCount","hiddenLabels","setHiddenLabels","showInstruction","setShowInstruction","showCelebration","setShowCelebration","draggedItem","setDraggedItem","type","index","startX","startY","imgData","setImgData","originalDimensions","setOriginalDimensions","width","height","textData","imageData","setImageData","useEditContext","imgRef","useRef","useEffect","lines","split","optionsLine","startsWith","shift","imageUrl","pop","showHiddenLabels","substring","forEach","option","key","value","length","hiddenPinCount","newPins","map","label","coordinateMatch","match","replace","push","xPercent","parseFloat","yPercent","x","y","labelX","labelY","hidden","labelAnswer","provided","adjustedIndex","Math","floor","sort","random","includes","LOCAL_MARKER","timeoutId","setTimeout","current","offsetWidth","offsetHeight","currentPins","pin","clearTimeout","timer","handleResize","scaleFactorWidth","scaleFactorHeight","rescaledPins","window","addEventListener","removeEventListener","onDragStart","e","dataTransfer","setData","item","updateImageData","data","_jsxs","_Fragment","children","className","styles","imagePinMaincontainer","imagePinContainer","draggable","onDragOver","preventDefault","onDrop","rect","getBoundingClientRect","endX","clientX","left","endY","clientY","top","moveX","moveY","_jsx","ref","imagePinImage","alt","onClick","prevPins","max","min","src","crossOrigin","fileUpload","accept","onChange","event","handleImageFileChange","target","files","React","concat","pinDraggable","style","onContextMenu","handleRightClick","filter","i","onDoubleClick","inputLabel","prompt","trim","toLowerCase","newHiddenCount","error","handleDoubleClick","pinLabel","correctLabel","errorLabel","imagePinInstruction","hiddenLabelsContainer","hiddenLabel","celebration"],"sourceRoot":""}