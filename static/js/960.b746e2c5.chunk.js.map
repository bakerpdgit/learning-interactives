{"version":3,"file":"static/js/960.b746e2c5.chunk.js","mappings":"gKAoKA,QAjKA,SAAgBA,GAAY,IAAX,KAAEC,GAAMD,EACvB,MAsCME,EAAgBC,IACpB,GAAIA,EAAMC,QAAU,EAClB,OAAOD,EAGT,IAAIE,EAAgB,IAAIF,GACxB,GACE,IAAK,IAAIG,EAAID,EAAcD,OAAS,EAAGE,EAAI,EAAGA,IAAK,CACjD,MAAMC,EAAIC,KAAKC,MAAMD,KAAKE,UAAYJ,EAAI,KACzCD,EAAcC,GAAID,EAAcE,IAAM,CACrCF,EAAcE,GACdF,EAAcC,GAElB,QACOD,EAAcM,OAAM,CAACC,EAAKC,IAAQD,IAAQT,EAAMU,MAEzD,OAAOR,CAAa,GAIhB,MAAES,EAAK,qBAAEC,GA7CKd,KAClB,MAAMe,EAAQf,EAAKgB,MAAM,QACzB,IAAIC,EAAU,CAAC,EAfKC,MAiBhBH,EAAM,GAAGI,WAAW,cAjBJD,EAkBKH,EAAMK,QAA7BH,EAjBKI,OAAOC,YACZJ,EACGK,UAAU,GACVP,MAAM,KACNQ,KAAKC,GAAWA,EAAOT,MAAM,SAgBlC,MAAMU,EAAOT,EAAQS,MAAQ,SAEvBb,EAAQE,EAAMS,KAAKG,IACvB,MAAOC,EAAMC,GAAQF,EAAKX,MAAM,MAChC,MAAO,CACLa,KAAM5B,EAAsB,SAATyB,EAAkBG,EAAKb,MAAM,KAAOa,EAAKb,MAAM,KAClEc,aAAcD,EACdD,OACAG,cAAwB,SAATL,EAAkBG,EAAKG,QAAQ,OAAQ,IAAMH,EAC7D,IAGGf,EACK,SAATY,GAzB4Bb,IACvBA,EAAMoB,MAAMN,GAA8B,IAArBA,EAAKE,KAAK1B,SAwBjB+B,CAAuBrB,GAC5C,MAAO,CAAEA,QAAOC,uBAAsB,EAuBAqB,CAAWnC,IAE5CoC,EAAWC,IAAgBC,EAAAA,EAAAA,UAASzB,IAEpC0B,EAAiBC,IAAsBF,EAAAA,EAAAA,UAASxB,GA8BjD2B,EAAaA,CAACC,EAAGC,EAAWC,KAChCF,EAAEG,iBACF,MAAQF,UAAWG,EAAeC,UAAWC,GAAcC,KAAKC,MAC9DR,EAAES,aAAaC,QAAQ,eAGrBN,IAAkBH,GAlCNU,EAACV,EAAWK,EAAWJ,KACvC,MAAMU,EAAe,IAAIlB,GACnBT,EAAO2B,EAAaX,IAGnBY,GAAe5B,EAAKE,KAAK2B,OAAOR,EAAW,GASlD,GANArB,EAAKE,KAAK2B,OAAOZ,EAAW,EAAGW,GAE/BlB,EAAaiB,GAEelB,EAAUO,GAAWd,KAAK4B,KAAK,MAE/BrB,EAAUO,GAAWZ,cAAe,CAC9D,MAAMuB,EAAe,IAAIlB,GACzBkB,EAAaX,GAAWe,WAAY,EACpCrB,EAAaiB,EACf,GAiBED,CAAUV,EAAWK,EAAWJ,EAClC,EAGIe,EAAkBjB,IACtBA,EAAEG,gBAAgB,GAGbe,EAAiBC,IAAsBvB,EAAAA,EAAAA,WAAS,GAWvD,OATAwB,EAAAA,EAAAA,YAAU,KACJ1B,EAAU1B,OAAOiB,GAASA,EAAK+B,cACjCG,GAAmB,GACnBE,YAAW,KACTF,GAAmB,EAAM,GACxB,KACL,GACC,CAACzB,KAGF4B,EAAAA,EAAAA,KAAAC,EAAAA,SAAA,CAAAC,UACEF,EAAAA,EAAAA,KAAA,OAAKG,UAAU,uBAAsBD,UACnCE,EAAAA,EAAAA,MAAA,OAAKD,UAAU,mBAAkBD,SAAA,CAC9B3B,IACCyB,EAAAA,EAAAA,KAAA,OAAKG,UAAU,QAAOD,SAAC,0GAKxBN,IAAmBI,EAAAA,EAAAA,KAAA,OAAKG,UAAU,cAAaD,SAAC,iBAChD9B,EAAUZ,KAAI,CAACG,EAAMgB,KACpByB,EAAAA,EAAAA,MAAA,OAEED,UAAS,QAAAE,OAAU1C,EAAK+B,UAAY,YAAc,IAAKQ,SAAA,EAEvDF,EAAAA,EAAAA,KAAA,OAAKG,UAAU,OAAMD,SAAEvC,EAAKC,QAC5BoC,EAAAA,EAAAA,KAAA,OAAKG,UAAU,OAAOG,WAAYX,EAAeO,SAC9CvC,EAAKE,KAAKL,KAAI,CAAC+C,EAAQC,KACtBR,EAAAA,EAAAA,KAAA,QAEEG,UAAS,QAAAE,OACPG,IAAgB7C,EAAK8C,aAAe,WAAa,IAEnDC,WAAY/C,EAAK+B,UACjBiB,YAAcjC,GA1DRkC,EAAClC,EAAGC,EAAWI,KACrCL,EAAES,aAAa0B,QACb,aACA5B,KAAK6B,UAAU,CAAEnC,YAAWI,cAC7B,EAuDiB6B,CAAgBlC,EAAGC,EAAW6B,GAEhCO,OAASrC,GAAMD,EAAWC,EAAGC,EAAW6B,GAAaN,SAEpDK,GAVIC,SAPN7B,WA2BnB,C","sources":["components/Anagram.js"],"sourcesContent":["import React, { useState, useEffect } from \"react\";\nimport \"./Anagram.css\";\n\nfunction Anagram({ text }) {\n  const parseOptions = (optionsLine) => {\n    return Object.fromEntries(\n      optionsLine\n        .substring(8)\n        .split(\";\")\n        .map((option) => option.split(\"=\"))\n    );\n  };\n\n  const checkSingleWordAnswers = (pairs) => {\n    return pairs.some((pair) => pair.word.length === 1);\n  };\n\n  const parseInput = (text) => {\n    const lines = text.split(\"\\n\\n\");\n    let options = {};\n\n    if (lines[0].startsWith(\"OPTIONS:\")) {\n      options = parseOptions(lines.shift());\n    }\n\n    const mode = options.mode || \"letter\";\n\n    const pairs = lines.map((pair) => {\n      const [clue, word] = pair.split(\"\\n\");\n      return {\n        word: shuffleArray(mode === \"word\" ? word.split(\" \") : word.split(\"\")),\n        originalWord: word,\n        clue,\n        correctAnswer: mode === \"word\" ? word.replace(/\\s+/g, \"\") : word,\n      };\n    });\n\n    const hasSingleWordAnswers =\n      mode === \"word\" && checkSingleWordAnswers(pairs);\n    return { pairs, hasSingleWordAnswers };\n  };\n\n  const shuffleArray = (array) => {\n    if (array.length <= 1) {\n      return array; // Return as-is for single item arrays\n    }\n\n    let shuffledArray = [...array];\n    do {\n      for (let i = shuffledArray.length - 1; i > 0; i--) {\n        const j = Math.floor(Math.random() * (i + 1));\n        [shuffledArray[i], shuffledArray[j]] = [\n          shuffledArray[j],\n          shuffledArray[i],\n        ];\n      }\n    } while (shuffledArray.every((val, idx) => val === array[idx])); // Reshuffle if the order is the same as original\n\n    return shuffledArray;\n  };\n\n  // Parse the input and initialize the state for word pairs\n  const { pairs, hasSingleWordAnswers } = parseInput(text);\n\n  const [wordPairs, setWordPairs] = useState(pairs);\n  // eslint-disable-next-line\n  const [singleWordError, setSingleWordError] = useState(hasSingleWordAnswers);\n\n  const swapTiles = (pairIndex, dragIndex, dropIndex) => {\n    const newWordPairs = [...wordPairs];\n    const pair = newWordPairs[pairIndex];\n\n    // Remove the dragged tile from its original position\n    const [draggedTile] = pair.word.splice(dragIndex, 1);\n\n    // Insert the dragged tile to the left of the drop position\n    pair.word.splice(dropIndex, 0, draggedTile);\n\n    setWordPairs(newWordPairs);\n\n    const reconstructedPhrase = wordPairs[pairIndex].word.join(\"\");\n\n    if (reconstructedPhrase === wordPairs[pairIndex].correctAnswer) {\n      const newWordPairs = [...wordPairs];\n      newWordPairs[pairIndex].completed = true;\n      setWordPairs(newWordPairs);\n    }\n  };\n\n  const handleDragStart = (e, pairIndex, tileIndex) => {\n    e.dataTransfer.setData(\n      \"text/plain\",\n      JSON.stringify({ pairIndex, tileIndex })\n    );\n  };\n\n  const handleDrop = (e, pairIndex, dropIndex) => {\n    e.preventDefault();\n    const { pairIndex: dragPairIndex, tileIndex: dragIndex } = JSON.parse(\n      e.dataTransfer.getData(\"text/plain\")\n    );\n\n    if (dragPairIndex === pairIndex) {\n      swapTiles(pairIndex, dragIndex, dropIndex);\n    }\n  };\n\n  const handleDragOver = (e) => {\n    e.preventDefault();\n  };\n\n  const [showCelebration, setShowCelebration] = useState(false);\n\n  useEffect(() => {\n    if (wordPairs.every((pair) => pair.completed)) {\n      setShowCelebration(true);\n      setTimeout(() => {\n        setShowCelebration(false);\n      }, 3000); // Hide the celebration icon after 2 seconds\n    }\n  }, [wordPairs]);\n\n  return (\n    <>\n      <div className=\"interactiveContainer\">\n        <div className=\"anagramContainer\">\n          {singleWordError && (\n            <div className=\"error\">\n              The puzzle below is not suitable because all answers should have\n              more than one word to use word mode.\n            </div>\n          )}\n          {showCelebration && <div className=\"celebration\">ðŸ˜ƒ</div>}\n          {wordPairs.map((pair, pairIndex) => (\n            <div\n              key={pairIndex}\n              className={`pair ${pair.completed ? \"completed\" : \"\"}`}\n            >\n              <div className=\"clue\">{pair.clue}</div>\n              <div className=\"word\" onDragOver={handleDragOver}>\n                {pair.word.map((letter, letterIndex) => (\n                  <span\n                    key={letterIndex}\n                    className={`tile ${\n                      letterIndex === pair.selectedTile ? \"selected\" : \"\"\n                    }`}\n                    draggable={!pair.completed}\n                    onDragStart={(e) =>\n                      handleDragStart(e, pairIndex, letterIndex)\n                    }\n                    onDrop={(e) => handleDrop(e, pairIndex, letterIndex)}\n                  >\n                    {letter}\n                  </span>\n                ))}\n              </div>\n            </div>\n          ))}\n        </div>\n      </div>\n    </>\n  );\n}\n\nexport default Anagram;\n"],"names":["_ref","text","shuffleArray","array","length","shuffledArray","i","j","Math","floor","random","every","val","idx","pairs","hasSingleWordAnswers","lines","split","options","optionsLine","startsWith","shift","Object","fromEntries","substring","map","option","mode","pair","clue","word","originalWord","correctAnswer","replace","some","checkSingleWordAnswers","parseInput","wordPairs","setWordPairs","useState","singleWordError","setSingleWordError","handleDrop","e","pairIndex","dropIndex","preventDefault","dragPairIndex","tileIndex","dragIndex","JSON","parse","dataTransfer","getData","swapTiles","newWordPairs","draggedTile","splice","join","completed","handleDragOver","showCelebration","setShowCelebration","useEffect","setTimeout","_jsx","_Fragment","children","className","_jsxs","concat","onDragOver","letter","letterIndex","selectedTile","draggable","onDragStart","handleDragStart","setData","stringify","onDrop"],"sourceRoot":""}