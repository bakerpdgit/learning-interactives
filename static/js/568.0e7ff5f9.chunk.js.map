{"version":3,"file":"static/js/568.0e7ff5f9.chunk.js","mappings":"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","sources":["webpack://my-react-app/./src/components/SelfReview.module.css?bfb6","components/SelfReview.js"],"sourcesContent":["// extracted by mini-css-extract-plugin\nexport default {\"selfReview\":\"SelfReview_selfReview__XPlJX\",\"questionContainer\":\"SelfReview_questionContainer__Oipih\",\"question\":\"SelfReview_question__pFBwN\",\"marksAvailable\":\"SelfReview_marksAvailable__peDzO\",\"questionProgress\":\"SelfReview_questionProgress__2wJg1\",\"answerInput\":\"SelfReview_answerInput__UNYOG\",\"marksScored\":\"SelfReview_marksScored__xrVZg\",\"markschemeContainer\":\"SelfReview_markschemeContainer__hLvJH\",\"markschemePoint\":\"SelfReview_markschemePoint__ywFii\",\"selected\":\"SelfReview_selected__2-Rx4\",\"reviewButton\":\"SelfReview_reviewButton__3ewA3\",\"reviewDisplay\":\"SelfReview_reviewDisplay__3KWUD\",\"reviewTable\":\"SelfReview_reviewTable__kwktq\",\"questionCell\":\"SelfReview_questionCell__Es-Ju\",\"markschemeCell\":\"SelfReview_markschemeCell__1drON\",\"reviewQuestionText\":\"SelfReview_reviewQuestionText__aGkwu\",\"reviewMarksAvailable\":\"SelfReview_reviewMarksAvailable__KQGFo\",\"userAnswer\":\"SelfReview_userAnswer__znmsu\",\"reviewMarkschemePoint\":\"SelfReview_reviewMarkschemePoint__kA7po\",\"overallScore\":\"SelfReview_overallScore__Se1Y7\",\"highlight\":\"SelfReview_highlight__YSPKJ\",\"celebration\":\"SelfReview_celebration__D40k7\",\"scale\":\"SelfReview_scale__zbR2C\",\"hide\":\"SelfReview_hide__8nWoX\"};","import React, { useState, useEffect } from \"react\";\nimport styles from \"./SelfReview.module.css\";\n\nconst processMarkschemePoint = (text) => {\n  // Use a regular expression to find words surrounded by asterisks\n  const regex = /\\*([^*]+)\\*/g;\n  return text.replace(regex, `<span class=${styles.highlight}>$1</span>`);\n};\n\nconst ReviewDisplay = ({ questions }) => {\n  const totalScore = questions.reduce(\n    (acc, question) =>\n      acc +\n      Math.min(\n        question.markscheme.filter((point) => point.selected).length,\n        question.marks\n      ),\n    0\n  );\n  const maxScore = questions.reduce((acc, question) => acc + question.marks, 0);\n\n  return (\n    <div className={styles.reviewDisplay}>\n      <table className={styles.reviewTable}>\n        <tbody>\n          {questions.map((question, index) => (\n            <tr key={index}>\n              <td className={styles.questionCell}>\n                <div className={styles.reviewQuestionText}>{question.text}</div>\n                <div className={styles.reviewMarksAvailable}>\n                  [{question.marks}]\n                </div>\n                <div className={styles.userAnswer}>{question.answer}</div>\n              </td>\n              <td className={styles.markschemeCell}>\n                {question.markscheme.map((point, index) => (\n                  <div\n                    key={index}\n                    className={`${styles.reviewMarkschemePoint} ${\n                      point.selected ? styles.selected : \"\"\n                    }`}\n                    dangerouslySetInnerHTML={{\n                      __html: processMarkschemePoint(point.text),\n                    }}\n                  >\n                    {/* point.text now processed and rendered with HTML */}\n                  </div>\n                ))}\n\n                <div className={styles.marksScored}>\n                  [\n                  {Math.min(\n                    question.markscheme.filter((point) => point.selected)\n                      .length,\n                    question.marks\n                  )}{\" \"}\n                  marks scored]\n                </div>\n              </td>\n            </tr>\n          ))}\n        </tbody>\n      </table>\n      <div className={styles.overallScore}>\n        Overall score: {totalScore} out of {maxScore}\n      </div>\n    </div>\n  );\n};\n\nconst QuestionDisplay = ({\n  question,\n  mode,\n  onAnswerChange,\n  onSelectMarkschemePoint,\n}) => {\n  const marksScored = Math.min(\n    question.markscheme.filter((point) => point.selected).length,\n    question.marks\n  );\n\n  return (\n    <div className={styles.questionContainer}>\n      <div className={styles.question}>{question.text}</div>\n      <div className={styles.marksAvailable}>[{question.marks}]</div>\n      <textarea\n        className={styles.answerInput}\n        value={question.answer}\n        onChange={(e) => onAnswerChange(e.target.value)}\n        placeholder=\"Type your answer here...\"\n        readOnly={mode !== \"question\"}\n      />\n      {mode === \"review\" && (\n        <>\n          <div className={styles.markschemeContainer}>\n            {question.markscheme.map((point, index) => (\n              <div\n                key={index}\n                onClick={() => onSelectMarkschemePoint(index)}\n                className={`${styles.markschemePoint} ${\n                  point.selected ? styles.selected : \"\"\n                }`}\n                dangerouslySetInnerHTML={{\n                  __html: processMarkschemePoint(point.text),\n                }}\n              >\n                {/* point.text now processed and rendered with HTML */}\n              </div>\n            ))}\n          </div>\n          <div className={styles.marksScored}>[{marksScored} marks scored]</div>\n        </>\n      )}\n    </div>\n  );\n};\n\nconst SelfReview = ({ text }) => {\n  const [currentQuestionIndex, setCurrentQuestionIndex] = useState(0);\n  const [questions, setQuestions] = useState([]);\n  const [title, setTitle] = useState(\"\");\n  const [isReviewMode, setIsReviewMode] = useState(false);\n  const [isReviewStage, setIsReviewStage] = useState(false);\n\n  const parseText = (text) => {\n    const sections = text.split(\"\\n\\n\");\n    const title = sections.shift();\n    let questions = sections.map((section, index) => {\n      const parts = section.split(\"\\n\").filter((part) => part.trim() !== \"\"); // Ensure empty lines are filtered out\n      return {\n        // Prefix the question number to the question text\n        text: `${index + 1}. ${parts[0]}`, // Adjusted here\n        marks: parseInt(parts[1], 10),\n        markscheme: parts.slice(2).map((markschemePoint) => ({\n          text: markschemePoint,\n          selected: false, // Initial state for selection\n        })),\n        answer: \"\", // Initial state for user's answer\n      };\n    });\n\n    return { title, questions };\n  };\n\n  useEffect(() => {\n    const { title, questions } = parseText(text);\n    setTitle(title);\n    setQuestions(questions);\n    setCurrentQuestionIndex(0);\n    setIsReviewMode(false);\n  }, [text]);\n\n  const toggleReviewMode = () => {\n    if (isReviewMode) {\n      setCurrentQuestionIndex((prev) =>\n        prev + 1 < questions.length ? prev + 1 : prev\n      );\n      if (currentQuestionIndex === questions.length - 1) {\n        setIsReviewStage(true);\n      }\n      setIsReviewMode(false);\n    } else {\n      setIsReviewMode(true);\n    }\n  };\n\n  const handleSelectMarkschemePoint = (questionIndex, pointIndex) => {\n    setQuestions((prevQuestions) =>\n      prevQuestions.map((question, qIndex) => {\n        if (qIndex === questionIndex) {\n          const newMarkscheme = question.markscheme.map((point, pIndex) => {\n            if (pIndex === pointIndex) {\n              return { ...point, selected: !point.selected };\n            }\n            return point;\n          });\n          return { ...question, markscheme: newMarkscheme };\n        }\n        return question;\n      })\n    );\n  };\n\n  const handleAnswerChange = (questionIndex, answer) => {\n    setQuestions((prevQuestions) =>\n      prevQuestions.map((question, qIndex) => {\n        if (qIndex === questionIndex) {\n          return { ...question, answer };\n        }\n        return question;\n      })\n    );\n  };\n\n  return (\n    <>\n      <h1 className=\"interactiveTitle\">{title}</h1>\n      <div className={styles.selfReview}>\n        {isReviewStage ? (\n          <>\n            <div className={styles.celebration}>😃</div>\n            <ReviewDisplay questions={questions} />\n          </>\n        ) : (\n          <>\n            {currentQuestionIndex < questions.length && (\n              <>\n                <QuestionDisplay\n                  question={questions[currentQuestionIndex]}\n                  mode={isReviewMode ? \"review\" : \"question\"}\n                  onAnswerChange={(answer) =>\n                    handleAnswerChange(currentQuestionIndex, answer)\n                  }\n                  onSelectMarkschemePoint={(pointIndex) =>\n                    handleSelectMarkschemePoint(\n                      currentQuestionIndex,\n                      pointIndex\n                    )\n                  }\n                />\n                <div className={styles.questionProgress}>\n                  [Question {currentQuestionIndex + 1} of {questions.length}]\n                </div>\n              </>\n            )}\n            <button onClick={toggleReviewMode} className={styles.reviewButton}>\n              {isReviewMode && currentQuestionIndex < questions.length - 1\n                ? \"Next\"\n                : isReviewMode\n                ? \"Review Summary\"\n                : \"Review\"}\n            </button>\n          </>\n        )}\n      </div>\n    </>\n  );\n};\n\nexport default SelfReview;\n"],"names":["processMarkschemePoint","text","replace","concat","styles","ReviewDisplay","_ref","questions","totalScore","reduce","acc","question","Math","min","markscheme","filter","point","selected","length","marks","maxScore","_jsxs","className","children","_jsx","map","index","answer","dangerouslySetInnerHTML","__html","QuestionDisplay","_ref2","mode","onAnswerChange","onSelectMarkschemePoint","marksScored","value","onChange","e","target","placeholder","readOnly","_Fragment","onClick","_ref3","currentQuestionIndex","setCurrentQuestionIndex","useState","setQuestions","title","setTitle","isReviewMode","setIsReviewMode","isReviewStage","setIsReviewStage","useEffect","sections","split","shift","section","parts","part","trim","parseInt","slice","markschemePoint","parseText","handleAnswerChange","questionIndex","prevQuestions","qIndex","pointIndex","handleSelectMarkschemePoint","newMarkscheme","pIndex","toggleReviewMode","prev"],"sourceRoot":""}