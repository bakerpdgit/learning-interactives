{"version":3,"file":"static/js/69.7257eabc.chunk.js","mappings":"0KACA,SAAgB,sBAAwB,yCAAyC,kBAAoB,qCAAqC,cAAgB,iCAAiC,SAAW,4BAA4B,aAAe,gCAAgC,WAAa,8BAA8B,sBAAwB,yCAAyC,YAAc,+BAA+B,oBAAsB,uCAAuC,IAAM,uBAAuB,aAAe,gCAAgC,YAAc,+BAA+B,UAAY,8B,aCI5mB,MAAMA,EAAe,UA+ZrB,QA7ZA,SAAkBC,GAAY,IAAX,KAAEC,GAAMD,EACzB,MAAOE,EAAMC,IAAWC,EAAAA,EAAAA,UAAS,KAC1BC,EAAaC,IAAkBF,EAAAA,EAAAA,UAAS,IACxCG,EAAcC,IAAmBJ,EAAAA,EAAAA,UAAS,KAC1CK,EAAiBC,IAAsBN,EAAAA,EAAAA,WAAS,IAChDO,EAAiBC,IAAsBR,EAAAA,EAAAA,WAAS,IAEhDS,EAAaC,IAAkBV,EAAAA,EAAAA,UAAS,CAC7CW,KAAM,KACNC,MAAO,KACPC,OAAQ,EACRC,OAAQ,KAEHC,EAASC,IAAchB,EAAAA,EAAAA,UAAS,OAChCiB,EAAoBC,IAAyBlB,EAAAA,EAAAA,UAAS,CAC3DmB,MAAO,EACPC,OAAQ,KAGJ,SAAEC,EAAQ,YAAEC,IAAgBC,EAAAA,EAAAA,KAE5BC,GAASC,EAAAA,EAAAA,QAAO,OAEtBC,EAAAA,EAAAA,YAAU,KACR,MAAMC,EAAQ9B,EAAK+B,MAAM,MACnBC,EAAcF,EAAM,GAAGG,WAAW,YAAcH,EAAMI,QAAU,KAChEC,EAAWL,EAAMM,MAEvB,IAAIC,GAAmB,EACvB,GAAIL,EAAa,CACCA,EAAYM,UAAU,GAAGP,MAAM,KACvCQ,SAASC,IACf,MAAOC,EAAKC,GAASF,EAAOT,MAAM,KACtB,SAARU,GAA4B,QAAVC,IACpBL,GAAmB,EACrB,GAEJ,CAEA,MAAM/B,EAAe,GAErB,GAAIwB,EAAMa,OAAS,EAAG,CACpB,IAAIC,EAAiB,EAErB,MAAMC,EAAUf,EAAMgB,KAAI,CAACC,EAAOhC,KAChC,MAAMiC,EAAkBD,EAAME,MAAM,oCACpC,GAAID,EAAiB,CACnBJ,IACAG,EAAQA,EAAMG,QAAQF,EAAgB,GAAI,IAC1C1C,EAAa6C,KAAKJ,GAClB,MAAMK,EAAWC,WAAWL,EAAgB,IACtCM,EAAWD,WAAWL,EAAgB,IACtCO,EAAKH,EAAW,IAAOhC,EAAmBE,MAC1CkC,EAAKF,EAAW,IAAOlC,EAAmBG,OAChD,MAAO,CACLgC,IACAC,IACAT,MAAO,GACPU,OAAQF,EACRG,OAAQF,EAAI,GACZG,QAAQ,EACRC,YAAab,EACbc,UAAU,EAEd,CAAO,CACL,MAAMC,EAAgB/C,EAAQ6B,EACxBW,EAAI,GAAqC,GAAhCQ,KAAKC,MAAMF,EAAgB,GACpCN,EAAI,GAAMM,EAAgB,EAAK,GACrC,MAAO,CACLP,IACAC,IACAT,QACAU,OAAQF,EACRG,OAAQF,EAAI,GACZG,QAAQ,EACRE,UAAU,EAEd,KAGF3D,EAAQ2C,GACRxC,EAAeuC,GAEXP,GAEF9B,EAAgBD,EAAa2D,MAAK,IAAMF,KAAKG,SAAW,KAE5D,CAEA/C,EACEgB,IAAaA,EAASgC,SAASrE,GAAgBqC,EAAWX,EAC3D,GACA,CAACxB,EAAMwB,EAAUJ,EAAmBE,MAAOF,EAAmBG,UAEjEM,EAAAA,EAAAA,YAAU,KAIR,MAAMuC,EAAYC,YAAW,KACvB1C,EAAO2C,UACTjD,EAAsB,CACpBC,MAAOK,EAAO2C,QAAQC,YACtBhD,OAAQI,EAAO2C,QAAQE,eAGzBtE,GAASuE,GACAA,EAAY3B,KAAK4B,GAGpBA,EAAInB,EAAI5B,EAAO2C,QAAQC,aACvBG,EAAIlB,EAAI7B,EAAO2C,QAAQE,aAGhB,IAAKE,EAAKnB,EAAG,IAAKC,EAAG,IAAKC,OAAQ,IAAKC,OAAQ,IAEjDgB,MAGb,GACC,KAEH,MAAO,IAAMC,aAAaP,EAAU,GACnC,CAAClD,KAEJW,EAAAA,EAAAA,YAAU,KACR,MAAM+C,EAAQP,YAAW,KACvB5D,GAAmB,EAAM,GACxB,KACH,MAAO,IAAMkE,aAAaC,EAAM,GAC/B,KAEH/C,EAAAA,EAAAA,YAAU,KACR,MAAMgD,EAAeA,KACnB,IACGlD,EAAO2C,SACqB,IAA7BlD,EAAmBE,OACW,IAA9BF,EAAmBG,OAEnB,OAIF,MAAMuD,EACJnD,EAAO2C,QAAQC,YAAcnD,EAAmBE,MAC5CyD,EACJpD,EAAO2C,QAAQE,aAAepD,EAAmBG,OAEnD,IAAIyD,EAAe/E,EAAK6C,KAAK4B,IAEpB,IACFA,EACHnB,EAAGmB,EAAInB,EAAIuB,EACXtB,EAAGkB,EAAIlB,EAAIuB,EACXtB,OAAQiB,EAAIjB,OAASqB,EACrBpB,OAAQgB,EAAIhB,OAASqB,MAIzBC,EAAeA,EAAalC,KAAK4B,GAG7BA,EAAInB,EAAI5B,EAAO2C,QAAQC,aACvBG,EAAIlB,EAAI7B,EAAO2C,QAAQE,aAGhB,IAAKE,EAAKnB,EAAG,IAAKC,EAAG,IAAKC,OAAQ,IAAKC,OAAQ,IAEjDgB,IAGTxE,EAAQ8E,GACJrD,EAAO2C,SACTjD,EAAsB,CACpBC,MAAOK,EAAO2C,QAAQC,YACtBhD,OAAQI,EAAO2C,QAAQE,cAE3B,EAOF,OAHAS,OAAOC,iBAAiB,SAAUL,GAG3B,KACLI,OAAOE,oBAAoB,SAAUN,EAAa,CACnD,GACA,CAACzD,EAAoBnB,IAExB,MAmFMmF,EAAcA,CAACC,EAAGtE,EAAOD,KAC7BuE,EAAEC,aAAaC,QAAQ,aAAc,IAGrC,MAAMC,EAAOvF,EAAKc,GACZC,EAAkB,QAATF,EAAiB0E,EAAKjC,EAAIiC,EAAK/B,OACxCxC,EAAkB,QAATH,EAAiB0E,EAAKhC,EAAIgC,EAAK9B,OAE9C7C,EAAe,CAAEC,OAAMC,QAAOC,SAAQC,UAAS,EAsC3CwE,EAAmBC,IACvBjE,EAAYiE,GACZvE,EAAWuE,EAAK,EAGlB,OACEC,EAAAA,EAAAA,MAAAC,EAAAA,SAAA,CAAAC,SAAA,EACEF,EAAAA,EAAAA,MAAA,OAAKG,UAAWC,EAAOC,sBAAsBH,SAAA,EAC3CF,EAAAA,EAAAA,MAAA,OACEG,UAAWC,EAAOE,kBAClBC,UAAU,QACVC,WA7CYd,IAClBA,EAAEe,gBAAgB,EA6CZC,OA1CQhB,IACd,IAAK1D,EAAO2C,SAAiC,OAAtB1D,EAAYG,MAAgB,OAEnD,MAAMuF,EAAO3E,EAAO2C,QAAQiC,wBAC5B,IAAIC,EAAOnB,EAAEoB,QAAUH,EAAKI,KACxBC,EAAOtB,EAAEuB,QAAUN,EAAKO,IAG5B,MAAMC,EAAQN,EAAO5F,EAAYI,OAC3B+F,EAAQJ,EAAO/F,EAAYK,OAEjCf,EACED,EAAK6C,KAAI,CAAC4B,EAAK3D,IACTA,IAAUH,EAAYG,MAEjB,IACF2D,EACHnB,EAAGmB,EAAInB,GAA0B,QAArB3C,EAAYE,KAAiBgG,EAAQ,GACjDtD,EAAGkB,EAAIlB,GAA0B,QAArB5C,EAAYE,KAAiBiG,EAAQ,GACjDtD,OAAQiB,EAAIjB,OAASqD,EACrBpD,OAAQgB,EAAIhB,OAASqD,GAGlBrC,KAIX7D,EAAe,CAAEC,KAAM,KAAMC,MAAO,KAAMC,OAAQ,EAAGC,OAAQ,GAAI,EAe5C4E,SAAA,GAEZ7F,EAAKmE,SAASrE,IAAiB0B,KAChCwF,EAAAA,EAAAA,KAAA,OACEC,IAAKtF,EACLmE,UAAWC,EAAOmB,cAClBC,IAAI,YACJC,QApJM/B,IAChB,IAAK1D,EAAO2C,QAAS,OAErB,MAAMgC,EAAO3E,EAAO2C,QAAQiC,wBAC5B,IAAIhD,EAAI8B,EAAEoB,QAAUH,EAAKI,KACrBlD,EAAI6B,EAAEuB,QAAUN,EAAKO,IAGzB3G,GAASmH,GAAa,IACjBA,EACH,CACE9D,EAAGQ,KAAKuD,IAAI,EAAGvD,KAAKwD,IAAIhE,EAAG+C,EAAKhF,MAAQ,KACxCkC,EAAGO,KAAKuD,IAAI,EAAGvD,KAAKwD,IAAI/D,EAAG8C,EAAK/E,OAAS,KACzCwB,MAAO,GACPU,OAAQF,EACRG,OAAQF,EAAI,GACZK,UAAU,KAEZ,EAmIQqC,UAAU,QACVsB,IAAKtG,EACLuG,YAAY,cAIfzH,EAAKmE,SAASrE,KAAkB0B,IAC/BmE,EAAAA,EAAAA,MAAA,OAAAE,SAAA,CAAK,+CAEHmB,EAAAA,EAAAA,KAAA,SAAO,KACPA,EAAAA,EAAAA,KAAA,SACElG,KAAK,OACLgF,UAAWC,EAAO2B,WAClBC,OAAO,UACPC,SAAWC,IACTC,EAAAA,EAAAA,IAAsBD,EAAME,OAAOC,MAAM,GAAIvC,QAMpDxF,EAAK6C,KAAI,CAAC4B,EAAK3D,KACd4E,EAAAA,EAAAA,MAACsC,EAAAA,SAAc,CAAApC,SAAA,EACbmB,EAAAA,EAAAA,KAAA,OAEElB,UAAS,GAAAoC,OAAKnC,EAAOrB,IAAG,KAAAwD,OACrBxD,EAAIf,OAA+B,GAAtBoC,EAAOoC,cAEvBC,MAAO,CAAE1B,KAAK,GAADwB,OAAKxD,EAAInB,EAAI,GAAE,MAAMsD,IAAI,GAADqB,OAAKxD,EAAIlB,EAAI,GAAE,OACpD0C,WAAYxB,EAAIf,OAChByB,YAAcC,GAAMD,EAAYC,EAAGtE,EAAO,OAC1CsH,cAAgBhD,GA/JLiD,EAACjD,EAAGtE,KAC3BsE,EAAEe,iBACFlG,GAASmH,GACPA,EAASkB,QAAO,CAAC7D,EAAK8D,IAAMA,IAAMzH,GAAS2D,EAAIb,YAChD,EA2JiCyE,CAAiBjD,EAAGtE,GAC1C0H,cAAeA,IAzJF1H,KACzB,MAAM2H,EAAaC,OAAO,8BAA+B1I,EAAKc,GAAOgC,OACrE,GAAmB,OAAf2F,EACF,GAAIzI,EAAKc,GAAO4C,OAUd,GATwB+E,EACrBE,OACAC,cACA3F,QAAQ,OAAQ,MACQjD,EAAKc,GAAO6C,YACpCgF,OACAC,cACA3F,QAAQ,OAAQ,IAEyB,CAC1ChD,EACED,EAAK6C,KAAI,CAAC4B,EAAK8D,IACbA,IAAMzH,EACF,IACK2D,EACH3B,MAAO9C,EAAKc,GAAO6C,YACnBD,QAAQ,GAEVe,KAGR,MAAMoE,EAAiB1I,EAAc,EACrCC,EAAeyI,GACQ,IAAnBA,GACFnI,GAAmB,EAEvB,MACET,EACED,EAAK6C,KAAI,CAAC4B,EAAK8D,IACbA,IAAMzH,EAAQ,IAAK2D,EAAK3B,MAAO,YAAagG,OAAO,GAASrE,KAGhEL,YAAW,KACTnE,EACED,EAAK6C,KAAI,CAAC4B,EAAK8D,IACbA,IAAMzH,EAAQ,IAAK2D,EAAK3B,MAAO,GAAIgG,OAAO,GAAUrE,IAEvD,GACA,UAGLxE,EACED,EAAK6C,KAAI,CAAC4B,EAAK8D,IACbA,IAAMzH,EAAQ,IAAK2D,EAAK3B,MAAO2F,GAAehE,IAItD,EAsGiCsE,CAAkBjI,IAAO,OAAAmH,OARlCnH,IAUb2D,EAAI3B,QACHiE,EAAAA,EAAAA,KAAA,OACElB,UAAS,GAAAoC,OAAKnC,EAAOkD,SAAQ,KAAAf,QACZ,IAAfxD,EAAIf,OAAkBoC,EAAOmD,aAAe,GAAE,KAAAhB,OAC5CxD,EAAIqE,MAAQhD,EAAOoD,WAAa,IACpCf,MAAO,CACL1B,KAAK,GAADwB,OAAKxD,EAAIjB,OAAM,MACnBoD,IAAI,GAADqB,OAAKxD,EAAIhB,OAAS,GAAE,OAEzBwC,UAAU,OACVd,YAAcC,GAAMD,EAAYC,EAAGtE,EAAO,SAAS8E,SAElDnB,EAAI3B,UAER,YAAAmF,OA1B8BnH,SA8BpCP,IACCmF,EAAAA,EAAAA,MAAA,OAAKG,UAAWC,EAAOqD,oBAAoBvD,SAAA,EACzCmB,EAAAA,EAAAA,KAAA,MAAAnB,SAAI,gBACJmB,EAAAA,EAAAA,KAAA,KAAAnB,SAAG,iHAORvF,IACC0G,EAAAA,EAAAA,KAAA,OAAKlB,UAAWC,EAAOsD,sBAAsBxD,SAC1CvF,EAAawC,KAAI,CAACC,EAAOhC,KACxBiG,EAAAA,EAAAA,KAAA,OAA+BlB,UAAWC,EAAOuD,YAAYzD,SAC1D9C,GAAK,YAAAmF,OADcnH,QAM3BL,IAAmBsG,EAAAA,EAAAA,KAAA,OAAKlB,UAAWC,EAAOwD,YAAY1D,SAAC,mBAG9D,C","sources":["webpack://my-react-app/./src/components/ImagePins.module.css?0275","components/ImagePins.js"],"sourcesContent":["// extracted by mini-css-extract-plugin\nexport default {\"imagePinMaincontainer\":\"ImagePins_imagePinMaincontainer__ve+Rp\",\"imagePinContainer\":\"ImagePins_imagePinContainer__gV26t\",\"imagePinImage\":\"ImagePins_imagePinImage__IpjTM\",\"pinLabel\":\"ImagePins_pinLabel__boY-Q\",\"correctLabel\":\"ImagePins_correctLabel__qIafK\",\"errorLabel\":\"ImagePins_errorLabel__8NLFJ\",\"hiddenLabelsContainer\":\"ImagePins_hiddenLabelsContainer__E33Kt\",\"hiddenLabel\":\"ImagePins_hiddenLabel__j-Yd4\",\"imagePinInstruction\":\"ImagePins_imagePinInstruction__yX44S\",\"pin\":\"ImagePins_pin__FcmAN\",\"pinDraggable\":\"ImagePins_pinDraggable__-W5-y\",\"celebration\":\"ImagePins_celebration__eLfSQ\",\"flyAcross\":\"ImagePins_flyAcross__HgWSj\"};","import React, { useState, useRef, useEffect } from \"react\";\nimport { handleImageFileChange } from \"../ImageUploads\";\nimport { useEditContext } from \"../EditContext\";\nimport styles from \"./ImagePins.module.css\";\n\nconst LOCAL_MARKER = \"[local]\";\n\nfunction ImagePins({ text }) {\n  const [pins, setPins] = useState([]);\n  const [hiddenCount, setHiddenCount] = useState(0);\n  const [hiddenLabels, setHiddenLabels] = useState([]); // Array of hidden labels [label1, label2, ...\n  const [showInstruction, setShowInstruction] = useState(true);\n  const [showCelebration, setShowCelebration] = useState(false);\n\n  const [draggedItem, setDraggedItem] = useState({\n    type: null,\n    index: null,\n    startX: 0,\n    startY: 0,\n  });\n  const [imgData, setImgData] = useState(null);\n  const [originalDimensions, setOriginalDimensions] = useState({\n    width: 0,\n    height: 0,\n  });\n\n  const { textData, setTextData } = useEditContext();\n\n  const imgRef = useRef(null);\n\n  useEffect(() => {\n    const lines = text.split(\"\\n\"); // Split the text by new lines\n    const optionsLine = lines[0].startsWith(\"OPTIONS:\") ? lines.shift() : null;\n    const imageUrl = lines.pop(); // The last line is the image URL\n\n    let showHiddenLabels = false;\n    if (optionsLine) {\n      const options = optionsLine.substring(8).split(\";\");\n      options.forEach((option) => {\n        const [key, value] = option.split(\"=\");\n        if (key === \"show\" && value === \"yes\") {\n          showHiddenLabels = true;\n        }\n      });\n    }\n\n    const hiddenLabels = [];\n\n    if (lines.length > 0) {\n      let hiddenPinCount = 0;\n\n      const newPins = lines.map((label, index) => {\n        const coordinateMatch = label.match(/\\((\\d+(\\.\\d+)?),(\\d+(\\.\\d+)?)\\)$/);\n        if (coordinateMatch) {\n          hiddenPinCount++;\n          label = label.replace(coordinateMatch[0], \"\"); // Remove the coordinates from the label\n          hiddenLabels.push(label);\n          const xPercent = parseFloat(coordinateMatch[1]);\n          const yPercent = parseFloat(coordinateMatch[3]);\n          const x = (xPercent / 100) * originalDimensions.width;\n          const y = (yPercent / 100) * originalDimensions.height;\n          return {\n            x,\n            y,\n            label: \"\",\n            labelX: x,\n            labelY: y - 40,\n            hidden: true, // Mark the label as hidden\n            labelAnswer: label,\n            provided: true, // given in setup so cannot be deleted\n          };\n        } else {\n          const adjustedIndex = index - hiddenPinCount;\n          const x = 50 + Math.floor(adjustedIndex / 5) * 70; // Move 50 pixels right for every new column of 5 labels\n          const y = 50 + (adjustedIndex % 5) * 70; // Place labels 70 pixels apart vertically\n          return {\n            x,\n            y,\n            label,\n            labelX: x,\n            labelY: y - 40,\n            hidden: false, // Visible label\n            provided: true,\n          };\n        }\n      });\n\n      setPins(newPins);\n      setHiddenCount(hiddenPinCount);\n\n      if (showHiddenLabels) {\n        // randomly shuffle the hidden labels\n        setHiddenLabels(hiddenLabels.sort(() => Math.random() - 0.5));\n      }\n    }\n\n    setImgData(\n      imageUrl && !imageUrl.includes(LOCAL_MARKER) ? imageUrl : textData\n    );\n  }, [text, textData, originalDimensions.width, originalDimensions.height]); // Dependency array includes textData to re-run this effect when textData changes\n\n  useEffect(() => {\n    // Assuming imgRef is a ref to your img element\n\n    // Set a timeout to wait for the image to stabilize\n    const timeoutId = setTimeout(() => {\n      if (imgRef.current) {\n        setOriginalDimensions({\n          width: imgRef.current.offsetWidth,\n          height: imgRef.current.offsetHeight,\n        });\n        // Adjust pins if necessary\n        setPins((currentPins) => {\n          return currentPins.map((pin) => {\n            // Check if the pin is outside the bounds of the image\n            if (\n              pin.x > imgRef.current.offsetWidth ||\n              pin.y > imgRef.current.offsetHeight\n            ) {\n              // Reset position to (100, 100) if outside bounds\n              return { ...pin, x: 100, y: 100, labelX: 100, labelY: 50 }; // Adjust labelY accordingly if needed\n            }\n            return pin; // Return the pin unchanged if it's within bounds\n          });\n        });\n      }\n    }, 1000); // 1 second delay to allow for image dimensions to stabilize\n\n    return () => clearTimeout(timeoutId); // Cleanup the timeout if the component unmounts or if textData changes again before the timeout finishes\n  }, [imgData]); // Dependency array includes textData to re-run this effect when textData changes\n\n  useEffect(() => {\n    const timer = setTimeout(() => {\n      setShowInstruction(false);\n    }, 1000);\n    return () => clearTimeout(timer);\n  }, []);\n\n  useEffect(() => {\n    const handleResize = () => {\n      if (\n        !imgRef.current ||\n        originalDimensions.width === 0 ||\n        originalDimensions.height === 0\n      )\n        return; // Ensure the image ref is available\n\n      // Example: Calculate new scale factors based on image's resized dimensions\n      // This assumes you have some way of determining or storing the original dimensions\n      const scaleFactorWidth =\n        imgRef.current.offsetWidth / originalDimensions.width;\n      const scaleFactorHeight =\n        imgRef.current.offsetHeight / originalDimensions.height;\n\n      let rescaledPins = pins.map((pin) => {\n        // Adjust each pin's position based on the scale factor\n        return {\n          ...pin,\n          x: pin.x * scaleFactorWidth,\n          y: pin.y * scaleFactorHeight,\n          labelX: pin.labelX * scaleFactorWidth,\n          labelY: pin.labelY * scaleFactorHeight,\n        };\n      });\n\n      rescaledPins = rescaledPins.map((pin) => {\n        // Check if the pin is outside the bounds of the image\n        if (\n          pin.x > imgRef.current.offsetWidth ||\n          pin.y > imgRef.current.offsetHeight\n        ) {\n          // Reset position to (100, 100) if outside bounds\n          return { ...pin, x: 100, y: 100, labelX: 100, labelY: 50 }; // Adjust labelY accordingly if needed\n        }\n        return pin; // Return the pin unchanged if it's within bounds\n      });\n\n      setPins(rescaledPins); // Update the state with the new positions\n      if (imgRef.current) {\n        setOriginalDimensions({\n          width: imgRef.current.offsetWidth,\n          height: imgRef.current.offsetHeight,\n        });\n      }\n    };\n\n    // Add resize listener\n    window.addEventListener(\"resize\", handleResize);\n\n    // Cleanup function to remove the listener\n    return () => {\n      window.removeEventListener(\"resize\", handleResize);\n    };\n  }, [originalDimensions, pins]); // Empty dependency array means this runs once on mount and cleanup on unmount\n\n  const placePin = (e) => {\n    if (!imgRef.current) return;\n\n    const rect = imgRef.current.getBoundingClientRect();\n    let x = e.clientX - rect.left;\n    let y = e.clientY - rect.top;\n\n    // Add new pin to the array\n    setPins((prevPins) => [\n      ...prevPins,\n      {\n        x: Math.max(0, Math.min(x, rect.width - 20)),\n        y: Math.max(0, Math.min(y, rect.height - 20)),\n        label: \"\",\n        labelX: x, // Initial Label X (same as pin X initially)\n        labelY: y - 40, // Initial Label Y (slightly above pin Y)\n        provided: false, // can be deleted\n      },\n    ]);\n  };\n\n  const handleRightClick = (e, index) => {\n    e.preventDefault(); // Prevent the browser context menu from opening\n    setPins((prevPins) =>\n      prevPins.filter((pin, i) => i !== index || pin.provided)\n    ); // Remove the pin at the clicked index\n  };\n\n  const handleDoubleClick = (index) => {\n    const inputLabel = prompt(\"Enter a label for this pin:\", pins[index].label);\n    if (inputLabel !== null) {\n      if (pins[index].hidden) {\n        const normalizedInput = inputLabel\n          .trim()\n          .toLowerCase()\n          .replace(/\\s+/g, \"\");\n        const normalizedOriginal = pins[index].labelAnswer\n          .trim()\n          .toLowerCase()\n          .replace(/\\s+/g, \"\");\n\n        if (normalizedInput === normalizedOriginal) {\n          setPins(\n            pins.map((pin, i) =>\n              i === index\n                ? {\n                    ...pin,\n                    label: pins[index].labelAnswer,\n                    hidden: true,\n                  }\n                : pin\n            )\n          );\n          const newHiddenCount = hiddenCount - 1;\n          setHiddenCount(newHiddenCount);\n          if (newHiddenCount === 0) {\n            setShowCelebration(true);\n          }\n        } else {\n          setPins(\n            pins.map((pin, i) =>\n              i === index ? { ...pin, label: \"try again\", error: true } : pin\n            )\n          );\n          setTimeout(() => {\n            setPins(\n              pins.map((pin, i) =>\n                i === index ? { ...pin, label: \"\", error: false } : pin\n              )\n            );\n          }, 1000);\n        }\n      } else {\n        setPins(\n          pins.map((pin, i) =>\n            i === index ? { ...pin, label: inputLabel } : pin\n          )\n        );\n      }\n    }\n  };\n\n  // Adjusted onDragStart to prevent default behavior\n  const onDragStart = (e, index, type) => {\n    e.dataTransfer.setData(\"text/plain\", \"\"); // For Firefox compatibility\n\n    // Determine initial position\n    const item = pins[index];\n    const startX = type === \"pin\" ? item.x : item.labelX;\n    const startY = type === \"pin\" ? item.y : item.labelY;\n\n    setDraggedItem({ type, index, startX, startY });\n  };\n\n  // Moved onDragOver to the image-pin-container\n  const onDragOver = (e) => {\n    e.preventDefault(); // This is crucial for allowing the drop\n  };\n\n  const onDrop = (e) => {\n    if (!imgRef.current || draggedItem.index === null) return;\n\n    const rect = imgRef.current.getBoundingClientRect();\n    let endX = e.clientX - rect.left;\n    let endY = e.clientY - rect.top;\n\n    // Calculate movement vector\n    const moveX = endX - draggedItem.startX;\n    const moveY = endY - draggedItem.startY;\n\n    setPins(\n      pins.map((pin, index) => {\n        if (index === draggedItem.index) {\n          // Apply movement vector to both pin and label\n          return {\n            ...pin,\n            x: pin.x + (draggedItem.type === \"pin\" ? moveX : 0),\n            y: pin.y + (draggedItem.type === \"pin\" ? moveY : 0),\n            labelX: pin.labelX + moveX,\n            labelY: pin.labelY + moveY,\n          };\n        }\n        return pin;\n      })\n    );\n\n    setDraggedItem({ type: null, index: null, startX: 0, startY: 0 }); // Reset after drop\n  };\n\n  const updateImageData = (data) => {\n    setTextData(data);\n    setImgData(data);\n  };\n\n  return (\n    <>\n      <div className={styles.imagePinMaincontainer}>\n        <div\n          className={styles.imagePinContainer}\n          draggable=\"false\" // Prevent the container from being draggable\n          onDragOver={onDragOver}\n          onDrop={onDrop}\n        >\n          {(!text.includes(LOCAL_MARKER) || textData) && (\n            <img\n              ref={imgRef}\n              className={styles.imagePinImage}\n              alt=\"Highlight\"\n              onClick={placePin}\n              draggable=\"false\"\n              src={imgData}\n              crossOrigin=\"anonymous\"\n            />\n          )}\n\n          {text.includes(LOCAL_MARKER) && !textData && (\n            <div>\n              The local image will need to be provided...\n              <br />{\" \"}\n              <input\n                type=\"file\"\n                className={styles.fileUpload}\n                accept=\"image/*\"\n                onChange={(event) =>\n                  handleImageFileChange(event.target.files[0], updateImageData)\n                }\n              />\n            </div>\n          )}\n\n          {pins.map((pin, index) => (\n            <React.Fragment key={`pinlabel-${index}`}>\n              <div\n                key={`pin-${index}`}\n                className={`${styles.pin} ${\n                  !pin.hidden ? styles.pinDraggable : \"\"\n                }`}\n                style={{ left: `${pin.x - 10}px`, top: `${pin.y - 10}px` }}\n                draggable={!pin.hidden}\n                onDragStart={(e) => onDragStart(e, index, \"pin\")}\n                onContextMenu={(e) => handleRightClick(e, index)}\n                onDoubleClick={() => handleDoubleClick(index)}\n              ></div>\n              {pin.label && (\n                <div\n                  className={`${styles.pinLabel} ${\n                    pin.hidden === true ? styles.correctLabel : \"\"\n                  } ${pin.error ? styles.errorLabel : \"\"}`}\n                  style={{\n                    left: `${pin.labelX}px`,\n                    top: `${pin.labelY - 10}px`,\n                  }}\n                  draggable=\"true\"\n                  onDragStart={(e) => onDragStart(e, index, \"label\")}\n                >\n                  {pin.label}\n                </div>\n              )}\n            </React.Fragment>\n          ))}\n        </div>\n        {showInstruction && (\n          <div className={styles.imagePinInstruction}>\n            <h1>Image Pins</h1>\n            <p>\n              click to drop pins, right-click to delete pin, double-click to add\n              a label; drag labels to reposition.\n            </p>\n          </div>\n        )}\n      </div>\n      {hiddenLabels && (\n        <div className={styles.hiddenLabelsContainer}>\n          {hiddenLabels.map((label, index) => (\n            <div key={`hiddenLbl${index}`} className={styles.hiddenLabel}>\n              {label}\n            </div>\n          ))}\n        </div>\n      )}\n      {showCelebration && <div className={styles.celebration}>ðŸŽº</div>}\n    </>\n  );\n}\n\nexport default ImagePins;\n"],"names":["LOCAL_MARKER","_ref","text","pins","setPins","useState","hiddenCount","setHiddenCount","hiddenLabels","setHiddenLabels","showInstruction","setShowInstruction","showCelebration","setShowCelebration","draggedItem","setDraggedItem","type","index","startX","startY","imgData","setImgData","originalDimensions","setOriginalDimensions","width","height","textData","setTextData","useEditContext","imgRef","useRef","useEffect","lines","split","optionsLine","startsWith","shift","imageUrl","pop","showHiddenLabels","substring","forEach","option","key","value","length","hiddenPinCount","newPins","map","label","coordinateMatch","match","replace","push","xPercent","parseFloat","yPercent","x","y","labelX","labelY","hidden","labelAnswer","provided","adjustedIndex","Math","floor","sort","random","includes","timeoutId","setTimeout","current","offsetWidth","offsetHeight","currentPins","pin","clearTimeout","timer","handleResize","scaleFactorWidth","scaleFactorHeight","rescaledPins","window","addEventListener","removeEventListener","onDragStart","e","dataTransfer","setData","item","updateImageData","data","_jsxs","_Fragment","children","className","styles","imagePinMaincontainer","imagePinContainer","draggable","onDragOver","preventDefault","onDrop","rect","getBoundingClientRect","endX","clientX","left","endY","clientY","top","moveX","moveY","_jsx","ref","imagePinImage","alt","onClick","prevPins","max","min","src","crossOrigin","fileUpload","accept","onChange","event","handleImageFileChange","target","files","React","concat","pinDraggable","style","onContextMenu","handleRightClick","filter","i","onDoubleClick","inputLabel","prompt","trim","toLowerCase","newHiddenCount","error","handleDoubleClick","pinLabel","correctLabel","errorLabel","imagePinInstruction","hiddenLabelsContainer","hiddenLabel","celebration"],"sourceRoot":""}