{"version":3,"file":"static/js/426.b804d6a5.chunk.js","mappings":"uMACA,SAAgB,qBAAuB,oCAAoC,oBAAsB,mCAAmC,YAAc,2BAA2B,MAAQ,qBAAqB,KAAO,oBAAoB,eAAiB,8BAA8B,UAAY,yBAAyB,aAAe,4BAA4B,eAAiB,+B,aCIrX,MAAMA,EACE,OAGFC,EAAgBC,IAAuC,IAAtC,GAAEC,EAAE,QAAEC,EAAO,MAAEC,EAAK,SAAEC,GAAUJ,EACrD,MAAMK,GAAMC,EAAAA,EAAAA,QAAO,OACZ,CAAEC,IAAQC,EAAAA,EAAAA,GAAQ,CACvBC,OAAQX,EACRY,KAAAA,CAAMC,EAAMC,GACV,IAAKP,EAAIQ,QACP,OAEF,MAAMC,EAAYH,EAAKR,MACjBY,EAAaZ,EACfW,IAAcC,IAGlBX,EAASU,EAAWC,GACpBJ,EAAKR,MAAQY,EACf,MAEK,WAAEC,GAAcC,IAAQC,EAAAA,EAAAA,GAAQ,CACrCC,KAAMrB,EACNa,KAAMA,KAAA,CAASV,KAAIE,UACnBiB,QAAUR,IAAO,CACfI,aAAcJ,EAAQI,iBAM1B,OAFAC,EAAKV,EAAKF,KAGRgB,EAAAA,EAAAA,KAAA,OACEhB,IAAKA,EACLiB,MAAO,CAAEC,QAASP,EAAa,GAAM,EAAGQ,OAAQ,QAChDC,UAAWC,EAAOC,UAAUC,SAE3B1B,GACG,EAIG2B,EAAaC,IAA0B,IAAzB,MAAEC,EAAK,SAAE3B,GAAU0B,EAC5C,OACET,EAAAA,EAAAA,KAAA,OAAKI,UAAWC,EAAOM,eAAeJ,SACnCG,EAAME,KAAI,CAACtB,EAAMR,KAChBkB,EAAAA,EAAAA,KAACtB,EAAa,CAEZI,MAAOA,EACPF,GAAIU,EAAKV,GACTC,QAASS,EAAKT,QACdE,SAAUA,GAJLO,EAAKV,OAOV,EAuIV,EAnIciC,IAAe,IAAd,KAAEC,GAAMD,EACrB,MAAOE,EAAOC,IAAYC,EAAAA,EAAAA,UAAS,KAC5BC,EAAQC,IAAaF,EAAAA,EAAAA,UAAS,KAC9BG,EAAmBC,IAAwBJ,EAAAA,EAAAA,UAAS,IACpDK,EAAgBC,IAAqBN,EAAAA,EAAAA,UAAS,KAC9CO,EAAaC,IAAkBR,EAAAA,EAAAA,WAAS,IAG/CS,EAAAA,EAAAA,YAAU,KACR,SAASC,EAAaC,GACpB,IACEC,EACAC,EAFEC,EAAeH,EAAMI,OAKzB,KAAO,IAAMD,GAEXD,EAAcG,KAAKC,MAAMD,KAAKE,SAAWJ,GACzCA,GAAgB,EAGhBF,EAAiBD,EAAMG,GACvBH,EAAMG,GAAgBH,EAAME,GAC5BF,EAAME,GAAeD,EAGvB,OAAOD,CACT,CAaA,MAiBM,MAAEb,EAAK,OAAEG,GAjBIJ,KAEjB,MAAMsB,EAAatB,EAAKuB,MAAM,QAY9B,MAAO,CAAEtB,MAXKqB,EAAWE,QAWTpB,OATDkB,EAAWxB,KAAI,CAAC2B,EAAOC,IAhBxC,SAAwBC,GACtB,IAAIC,EACJ,GACEA,EAAWf,EAAa,IAAIc,UAE5BC,EAASV,OAAS,GAClBU,EAASC,OAAM,CAACrD,EAAMR,IAAUQ,EAAKV,KAAO6D,EAAS3D,GAAOF,MAE9D,OAAO8D,CACT,CAQIE,CAEEL,EAAMF,MAAM,MAAMzB,KAAI,CAACiC,EAAM/D,KAAK,CAChCF,GAAG,SAADkE,OAAWN,EAAU,UAAAM,OAAShE,GAChCD,QAASgE,SAIS,EAGAE,CAAUjC,GACpCE,EAASD,GACTI,EAAUD,GACVG,EAAqB,GACrBI,GAAe,EAAM,GAEpB,CAACX,IA2CJ,OACEkC,EAAAA,EAAAA,MAAAC,EAAAA,SAAA,CAAA1C,SAAA,EACEP,EAAAA,EAAAA,KAAA,MAAII,UAAWC,EAAO6C,oBAAoB3C,SAAEQ,KAC5Cf,EAAAA,EAAAA,KAAA,OAAKI,UAAU,eAAcG,UACzBiB,IAAexB,EAAAA,EAAAA,KAAA,UAAQmD,QApCZC,KACClC,EAAOE,GAAmBuB,OAC1C,CAACrD,EAAMR,IAAUQ,EAAKV,KAAE,SAAAkE,OAAc1B,EAAiB,UAAA0B,OAAShE,KAI5DsC,EAAoBF,EAAOc,OAAS,GAEtCX,EAAqBD,EAAoB,GACzCG,EAAkBlB,EAAOgD,cACzBC,YAAW,KACT/B,EAAkB,GAAG,GACpB,OAKHE,GAAe,GACfF,EAAkBlB,EAAOgD,cACzBC,YAAW,KACT/B,EAAkB,GAAG,GACpB,OAILA,EAAkBlB,EAAOkD,gBACzBD,YAAW,KACT/B,EAAkB,GAAG,GACpB,KACL,EAOiDhB,SAAC,cAEhDyC,EAAAA,EAAAA,MAAA,OAAK5C,UAAS,GAAA0C,OAAKzC,EAAOmD,qBAAoB,yBAAwBjD,SAAA,EACpEP,EAAAA,EAAAA,KAAA,OAAKI,UAAS,GAAA0C,OAAKzC,EAAOM,eAAc,KAAAmC,OAAIxB,GAAiBf,SAC1DW,EAAOc,OAAS,IACfhC,EAAAA,EAAAA,KAACQ,EAAU,CAACE,MAAOQ,EAAOE,GAAoBrC,SAlDvCA,CAACU,EAAWC,KAC3B,MAAM+D,EAAY,IAAIvC,GAChBwC,EAAWD,EAAUrC,GAAmB3B,GAC9CgE,EAAUrC,GAAmBuC,OAAOlE,EAAW,GAC/CgE,EAAUrC,GAAmBuC,OAAOjE,EAAY,EAAGgE,GACnDvC,EAAUsC,EAAU,MAiDfjC,GACCxB,EAAAA,EAAAA,KAAA,OAAKI,UAAWC,EAAOuD,YAAYrD,UACjCP,EAAAA,EAAAA,KAAA,QAAMI,UAAWC,EAAOwD,MAAOC,KAAK,MAAM,aAAW,YAAWvD,SAAC,mBAIjE,UAEL,C","sources":["webpack://class-interactives/./src/components/Order.module.css?0c58","components/Order.js"],"sourcesContent":["// extracted by mini-css-extract-plugin\nexport default {\"interactiveContainer\":\"Order_interactiveContainer__Z1Med\",\"interactiveSubTitle\":\"Order_interactiveSubTitle__ybECy\",\"celebration\":\"Order_celebration__D+8Gs\",\"scale\":\"Order_scale__6Ha43\",\"hide\":\"Order_hide__UoeD6\",\"stackContainer\":\"Order_stackContainer__Or4Aa\",\"stackItem\":\"Order_stackItem__MBig0\",\"correctFlash\":\"Order_correctFlash__NYL3K\",\"incorrectFlash\":\"Order_incorrectFlash__xaCti\"};","import React, { useRef, useState, useEffect } from \"react\";\nimport { useDrag, useDrop } from \"react-dnd\";\nimport styles from \"./Order.module.css\";\n\n// ItemTypes.js\nconst ItemTypes = {\n  ITEM: \"item\",\n};\n\nconst DraggableItem = ({ id, content, index, moveItem }) => {\n  const ref = useRef(null);\n  const [, drop] = useDrop({\n    accept: ItemTypes.ITEM,\n    hover(item, monitor) {\n      if (!ref.current) {\n        return;\n      }\n      const dragIndex = item.index;\n      const hoverIndex = index;\n      if (dragIndex === hoverIndex) {\n        return;\n      }\n      moveItem(dragIndex, hoverIndex);\n      item.index = hoverIndex;\n    },\n  });\n  const [{ isDragging }, drag] = useDrag({\n    type: ItemTypes.ITEM,\n    item: () => ({ id, index }),\n    collect: (monitor) => ({\n      isDragging: !!monitor.isDragging(),\n    }),\n  });\n\n  drag(drop(ref));\n\n  return (\n    <div\n      ref={ref}\n      style={{ opacity: isDragging ? 0.5 : 1, cursor: \"move\" }}\n      className={styles.stackItem}\n    >\n      {content}\n    </div>\n  );\n};\n\nexport const OrderStack = ({ items, moveItem }) => {\n  return (\n    <div className={styles.stackContainer}>\n      {items.map((item, index) => (\n        <DraggableItem\n          key={item.id}\n          index={index}\n          id={item.id}\n          content={item.content}\n          moveItem={moveItem}\n        />\n      ))}\n    </div>\n  );\n};\n\nconst Order = ({ text }) => {\n  const [title, setTitle] = useState(\"\");\n  const [groups, setGroups] = useState([]);\n  const [currentGroupIndex, setCurrentGroupIndex] = useState(0);\n  const [animationClass, setAnimationClass] = useState(\"\");\n  const [isCompleted, setIsCompleted] = useState(false);\n\n  // useEffect hook to parse text prop\n  useEffect(() => {\n    function shuffleArray(array) {\n      let currentIndex = array.length,\n        temporaryValue,\n        randomIndex;\n\n      // While there remain elements to shuffle...\n      while (0 !== currentIndex) {\n        // Pick a remaining element...\n        randomIndex = Math.floor(Math.random() * currentIndex);\n        currentIndex -= 1;\n\n        // And swap it with the current element.\n        temporaryValue = array[currentIndex];\n        array[currentIndex] = array[randomIndex];\n        array[randomIndex] = temporaryValue;\n      }\n\n      return array;\n    }\n\n    function ensureShuffled(original) {\n      let shuffled;\n      do {\n        shuffled = shuffleArray([...original]);\n      } while (\n        shuffled.length > 1 &&\n        shuffled.every((item, index) => item.id === original[index].id)\n      );\n      return shuffled;\n    }\n\n    const parseText = (text) => {\n      // Split the text by double newline to separate title and groups\n      const groupsText = text.split(\"\\n\\n\");\n      const title = groupsText.shift();\n\n      const groups = groupsText.map((group, groupIndex) =>\n        ensureShuffled(\n          // Ensure each group is shuffled\n          group.split(\"\\n\").map((line, index) => ({\n            id: `group-${groupIndex}-item-${index}`,\n            content: line,\n          }))\n        )\n      );\n      return { title, groups };\n    };\n\n    const { title, groups } = parseText(text);\n    setTitle(title);\n    setGroups(groups);\n    setCurrentGroupIndex(0); // Reset to the first group\n    setIsCompleted(false); // Reset completion status\n    // Ensure this effect runs whenever the text prop changes\n  }, [text]);\n\n  const moveItem = (dragIndex, hoverIndex) => {\n    const newGroups = [...groups];\n    const dragItem = newGroups[currentGroupIndex][dragIndex];\n    newGroups[currentGroupIndex].splice(dragIndex, 1);\n    newGroups[currentGroupIndex].splice(hoverIndex, 0, dragItem);\n    setGroups(newGroups);\n  };\n\n  // Implement the checkOrder function\n  const checkOrder = () => {\n    const isCorrect = groups[currentGroupIndex].every(\n      (item, index) => item.id === `group-${currentGroupIndex}-item-${index}`\n    );\n\n    if (isCorrect) {\n      if (currentGroupIndex < groups.length - 1) {\n        // Move to the next group\n        setCurrentGroupIndex(currentGroupIndex + 1);\n        setAnimationClass(styles.correctFlash);\n        setTimeout(() => {\n          setAnimationClass(\"\");\n        }, 1000);\n\n        // Reset animation class for the next group after the animation ends\n      } else {\n        // All groups completed\n        setIsCompleted(true);\n        setAnimationClass(styles.correctFlash);\n        setTimeout(() => {\n          setAnimationClass(\"\");\n        }, 1000);\n      }\n    } else {\n      // Incorrect order\n      setAnimationClass(styles.incorrectFlash);\n      setTimeout(() => {\n        setAnimationClass(\"\");\n      }, 1000);\n    }\n  };\n\n  return (\n    <>\n      <h1 className={styles.interactiveSubTitle}>{title}</h1>\n      <div className=\"instructions\">\n        {!isCompleted && <button onClick={checkOrder}>Submit</button>}\n      </div>\n      <div className={`${styles.interactiveContainer} interactiveContainer`}>\n        <div className={`${styles.stackContainer} ${animationClass}`}>\n          {groups.length > 0 && (\n            <OrderStack items={groups[currentGroupIndex]} moveItem={moveItem} />\n          )}\n        </div>\n\n        {isCompleted ? (\n          <div className={styles.celebration}>\n            <span className={styles.emoji} role=\"img\" aria-label=\"celebrate\">\n              ðŸŽ‰\n            </span>\n          </div>\n        ) : null}\n      </div>\n    </>\n  );\n};\n\nexport default Order;\n"],"names":["ItemTypes","DraggableItem","_ref","id","content","index","moveItem","ref","useRef","drop","useDrop","accept","hover","item","monitor","current","dragIndex","hoverIndex","isDragging","drag","useDrag","type","collect","_jsx","style","opacity","cursor","className","styles","stackItem","children","OrderStack","_ref2","items","stackContainer","map","_ref3","text","title","setTitle","useState","groups","setGroups","currentGroupIndex","setCurrentGroupIndex","animationClass","setAnimationClass","isCompleted","setIsCompleted","useEffect","shuffleArray","array","temporaryValue","randomIndex","currentIndex","length","Math","floor","random","groupsText","split","shift","group","groupIndex","original","shuffled","every","ensureShuffled","line","concat","parseText","_jsxs","_Fragment","interactiveSubTitle","onClick","checkOrder","correctFlash","setTimeout","incorrectFlash","interactiveContainer","newGroups","dragItem","splice","celebration","emoji","role"],"sourceRoot":""}