{"version":3,"file":"static/js/142.4c8a5c61.chunk.js","mappings":"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","sources":["components/WordBanks.js"],"sourcesContent":["import React, { useState, useEffect } from \"react\";\nimport \"./WordBanks.css\";\n\nfunction WordBanks({ text }) {\n  const shuffleArray = (array) => {\n    let shuffledArray = [...array];\n    for (let i = shuffledArray.length - 1; i > 0; i--) {\n      const j = Math.floor(Math.random() * (i + 1));\n      [shuffledArray[i], shuffledArray[j]] = [\n        shuffledArray[j],\n        shuffledArray[i],\n      ];\n    }\n    return shuffledArray;\n  };\n\n  const generateUUID = () => {\n    return (\n      Math.random().toString(36).substring(2, 15) +\n      Math.random().toString(36).substring(2, 15)\n    );\n  };\n  const parseInput = (text) => {\n    const lines = text.split(\"\\n\").map((line, lineIndex) => {\n      let sentenceParts = [];\n      let wordBank = [];\n      let currentWord = \"\";\n\n      const processAsteriskWord = (substring) => {\n        let extractedWord = \"\";\n        let i = 0;\n        // Skip the asterisk itself\n        i++;\n\n        while (i < substring.length) {\n          const char = substring[i];\n          // Check if it's acceptable punctuation within an asterisked word (e.g., decimals)\n          const isAcceptablePunctuation =\n            char === \".\" &&\n            i + 1 < substring.length &&\n            /\\d/.test(substring[i + 1]);\n          // Continue if it's a letter, digit, or acceptable punctuation; stop otherwise\n          if (/\\w/.test(char) || isAcceptablePunctuation) {\n            extractedWord += char;\n          } else {\n            // Stop on encountering other punctuation or whitespace unless first character\n            // or unless it is a hyphen or underscore\n            if (i === 0 || /[-_]/.test(char)) {\n              extractedWord += char;\n            } else {\n              break;\n            }\n          }\n          i++;\n        }\n\n        // Return the extracted word and the remaining substring\n        return { extractedWord, remainder: substring.slice(i) };\n      };\n\n      let i = 0;\n      while (i < line.length) {\n        const char = line[i];\n        if (char === \"*\" && currentWord.length === 0) {\n          if (currentWord) {\n            // End current word on encountering an asterisk\n            sentenceParts.push({\n              word: currentWord,\n              location: \"sentence\",\n              isTile: false,\n              uuid: null,\n            });\n            currentWord = \"\";\n          }\n          // Process the asterisk word\n          const { extractedWord, remainder } = processAsteriskWord(\n            line.slice(i)\n          );\n          // Add the extracted word to the word bank\n          wordBank.push({\n            word: extractedWord,\n            location: \"bank\",\n            isTile: true,\n            uuid: generateUUID(),\n            lineIndex,\n          });\n\n          sentenceParts.push({\n            word: \"\",\n            location: \"sentence\",\n            isTile: true,\n            uuid: generateUUID(), // Assign a UUID\n          });\n\n          line = remainder;\n          i = 0;\n        } else {\n          if (/\\s/.test(char) && currentWord) {\n            // End current word on encountering whitespace\n            sentenceParts.push({\n              word: currentWord,\n              location: \"sentence\",\n              isTile: false,\n              uuid: null,\n            });\n            currentWord = \"\";\n          } else if (!/\\s/.test(char)) {\n            currentWord += char;\n          }\n          i++;\n        }\n      }\n\n      // Check for any remaining word at the end\n      if (currentWord) {\n        sentenceParts.push({\n          word: currentWord,\n          location: \"sentence\",\n          isTile: false,\n          uuid: null,\n        });\n      }\n\n      // Shuffle the word bank\n      wordBank = shuffleArray(wordBank);\n\n      return {\n        sentence: sentenceParts.map((part, index) => ({\n          ...part,\n          index,\n          uuid: part.uuid,\n        })),\n        wordBank,\n        completed: false,\n      };\n    });\n\n    return lines;\n  };\n\n  const [lines, setLines] = useState(parseInput(text));\n  const [showCelebration, setShowCelebration] = useState(false);\n  const [draggedWord, setDraggedWord] = useState(null);\n\n  const onDragStart = (word) => {\n    setDraggedWord(word);\n  };\n\n  const isSentenceCorrect = (sentence, originalLine) => {\n    // Join the words in the sentence, then remove all whitespace\n    const currentSentence = sentence\n      .map((wordObj) => wordObj.word)\n      .join(\"\")\n      .replace(/\\s+/g, \"\"); // Remove all whitespace\n\n    // Remove asterisks and all whitespace from the original sentence\n    const originalSentence = originalLine\n      .replace(/\\*/g, \"\")\n      .replace(/\\s+/g, \"\"); // Remove all whitespace\n\n    // Compare the two strings\n    return currentSentence === originalSentence;\n  };\n\n  useEffect(() => {\n    let timer;\n    if (showCelebration) {\n      timer = setTimeout(() => {\n        setShowCelebration(false);\n      }, 3000); // Hide the celebration after 3 seconds\n    }\n    return () => clearTimeout(timer); // Clear the timer when the component unmounts or the effect re-runs\n  }, [showCelebration]);\n\n  const onDrop = (lineIndex, wordIndex) => {\n    // Validation to ensure words are not dragged across different lines\n    if (draggedWord.lineIndex !== lineIndex) {\n      return; // Exit the function if the word is being dragged to a different line\n    }\n    let newLines = [...lines];\n    let currentLine = { ...newLines[lineIndex] };\n    let wordBank = [...currentLine.wordBank];\n\n    // Case 1: Dragged from bank\n    if (draggedWord.location === \"bank\") {\n      const draggedWordObj = wordBank.find((w) => w.uuid === draggedWord.uuid);\n      if (draggedWordObj) {\n        wordBank = wordBank.filter((w) => w.uuid !== draggedWord.uuid);\n\n        // Check if the target location is occupied, and if so, move that word back to the bank\n        if (currentLine.sentence[wordIndex].word !== \"\") {\n          wordBank.push(currentLine.sentence[wordIndex]);\n        }\n\n        currentLine.sentence[wordIndex] = draggedWordObj;\n      }\n    }\n    // Case 2: Dragged from sentence\n    else if (draggedWord.location === \"sentence\") {\n      const originalLocation = currentLine.sentence[draggedWord.index];\n\n      // Replace original location with a blank tile\n      currentLine.sentence[draggedWord.index] = {\n        word: \"\",\n        location: \"sentence\",\n        index: draggedWord.index,\n      };\n\n      // If the target location is occupied, move that word back to the bank\n      if (currentLine.sentence[wordIndex].word !== \"\") {\n        wordBank.push(currentLine.sentence[wordIndex]);\n      }\n\n      currentLine.sentence[wordIndex] = originalLocation;\n    }\n\n    currentLine.wordBank = wordBank; // Update the word bank\n    newLines[lineIndex] = currentLine;\n\n    // Check if the current sentence is correct\n    newLines[lineIndex].completed = isSentenceCorrect(\n      newLines[lineIndex].sentence,\n      text.split(\"\\n\")[lineIndex]\n    );\n\n    // Check if all sentences are completed\n    const allCompleted = newLines.every((line) => line.completed);\n    setShowCelebration(allCompleted);\n\n    setLines(newLines);\n    setDraggedWord(null);\n  };\n\n  const renderSentence = (sentence, lineIndex) => {\n    const sentenceCompleted = lines[lineIndex].completed;\n    const sentenceClass = sentenceCompleted ? \"sentence completed\" : \"sentence\";\n\n    return (\n      <div key={lineIndex} className={sentenceClass}>\n        {sentence.map((wordObj, wordIndex) => {\n          if (wordObj.word === \"\") {\n            // Blank tile - drop zone but not draggable\n            return (\n              <span\n                key={wordIndex}\n                className=\"wordTile gap\"\n                onDrop={() => onDrop(lineIndex, wordIndex)}\n                onDragOver={(e) => e.preventDefault()}\n              >\n                _____\n              </span>\n            );\n          } else {\n            // Regular words are not droppable\n            const wordClass = wordObj.isTile\n              ? \"wordTile draggable\"\n              : \"regularWord\";\n            return (\n              <span\n                key={wordIndex}\n                className={wordClass}\n                draggable={wordObj.isTile}\n                onDragStart={\n                  wordObj.isTile\n                    ? () =>\n                        onDragStart({\n                          ...wordObj,\n                          location: \"sentence\",\n                          index: wordIndex,\n                        })\n                    : undefined\n                }\n                onDrop={\n                  wordObj.isTile\n                    ? () => onDrop(lineIndex, wordIndex)\n                    : undefined\n                }\n                onDragOver={(e) => e.preventDefault()}\n              >\n                {wordObj.word}\n              </span>\n            );\n          }\n        })}\n      </div>\n    );\n  };\n\n  const renderWordBank = (wordBank, lineIndex) => {\n    return wordBank.map((wordObj, index) => (\n      <span\n        key={index}\n        className=\"wordTile draggable\"\n        draggable\n        onDragStart={() => onDragStart({ ...wordObj, location: \"bank\", index })}\n      >\n        {wordObj.word}\n      </span>\n    ));\n  };\n\n  return (\n    <>\n      <div className=\"interactiveContainer\">\n        <div className=\"dragToGapContainer\">\n          {lines.map((line, index) => (\n            <div key={index}>\n              <div className=\"sentence\">\n                {renderSentence(line.sentence, index)}\n              </div>\n              <div className=\"wordBank\">\n                {renderWordBank(line.wordBank, index)}\n              </div>\n            </div>\n          ))}\n          {showCelebration && <div className=\"celebration\">😃</div>}\n        </div>\n      </div>\n    </>\n  );\n}\n\nexport default WordBanks;\n"],"names":["_ref","text","generateUUID","Math","random","toString","substring","lines","setLines","useState","split","map","line","lineIndex","sentenceParts","wordBank","currentWord","processAsteriskWord","extractedWord","i","length","char","isAcceptablePunctuation","test","remainder","slice","push","word","location","isTile","uuid","array","shuffledArray","j","floor","shuffleArray","sentence","part","index","completed","parseInput","showCelebration","setShowCelebration","draggedWord","setDraggedWord","onDragStart","useEffect","timer","setTimeout","clearTimeout","onDrop","wordIndex","newLines","currentLine","draggedWordObj","find","w","filter","originalLocation","isSentenceCorrect","originalLine","wordObj","join","replace","allCompleted","every","renderSentence","sentenceClass","_jsx","className","children","onDragOver","e","preventDefault","wordClass","draggable","undefined","_Fragment","_jsxs","renderWordBank"],"sourceRoot":""}