{"version":3,"file":"static/js/521.d53d1fbf.chunk.js","mappings":"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","sources":["components/MathComponent.js","components/Tarsia.js"],"sourcesContent":["import { InlineMath } from \"react-katex\";\r\n\r\nfunction parseAndRenderMath(text) {\r\n  // Split the text based on $$ delimiters\r\n  const segments = text.split(\"$$\");\r\n  const elements = [];\r\n\r\n  segments.forEach((segment, index) => {\r\n    if (index % 2 === 1) {\r\n      // Odd-indexed segments are LaTeX (since they are enclosed between $$ delimiters)\r\n      elements.push(<InlineMath key={`MCIM${index}`} math={segment} />);\r\n    } else {\r\n      elements.push(<span key={`MCSP${index}`}>{segment}</span>);\r\n    }\r\n  });\r\n\r\n  return elements;\r\n}\r\n\r\nconst renderWithNewLines = (text) => {\r\n  return text.replace(/\\\\n/g, \"\\n\");\r\n};\r\n\r\nfunction MathComponent({ text, renderNewLines = false }) {\r\n  if (renderNewLines) {\r\n    text = renderWithNewLines(text);\r\n  }\r\n\r\n  return (\r\n    <div\r\n      style={{\r\n        whiteSpace:\r\n          text.includes(\"\\n\") && renderNewLines ? \"pre-wrap\" : \"normal\",\r\n        marginTop: text.includes(\"$$\") ? \"0.5em\" : \"0\",\r\n      }}\r\n    >\r\n      {parseAndRenderMath(text)}\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default MathComponent;\r\n","import React, {\r\n  useState,\r\n  useImperativeHandle,\r\n  forwardRef,\r\n  useRef,\r\n  useEffect,\r\n} from \"react\";\r\nimport \"./Tarsia.css\";\r\nimport MathComponent from \"./MathComponent.js\";\r\n\r\nconst SquareComponent = forwardRef((props, ref) => {\r\n  const { lb1, lb2, lb3, lb4, isSelected, onSelect, sqSize } = props;\r\n  // eslint-disable-next-line\r\n  const [labels, setLabels] = useState([lb1, lb2, lb3, lb4]);\r\n\r\n  useImperativeHandle(ref, () => ({\r\n    getLabels: () => labels,\r\n    setLabels: (newLabels) => setLabels(newLabels),\r\n    rotateLabels: () => {\r\n      setLabels((prevLabels) => [prevLabels[3], ...prevLabels.slice(0, 3)]);\r\n    },\r\n  }));\r\n\r\n  return (\r\n    <div\r\n      style={{ width: `${sqSize}px`, height: `${sqSize}px` }}\r\n      className={`square ${isSelected ? \"selected\" : \"\"}`}\r\n      onClick={onSelect}\r\n    >\r\n      <div className=\"label top\">\r\n        {\" \"}\r\n        <MathComponent text={labels[0]} renderNewLines={true} />\r\n      </div>\r\n      <div className=\"label right\">\r\n        {\" \"}\r\n        <MathComponent text={labels[1]} renderNewLines={true} />\r\n      </div>\r\n      <div className=\"label bottom\">\r\n        {\" \"}\r\n        <MathComponent text={labels[2]} renderNewLines={true} />\r\n      </div>\r\n      <div className=\"label left\">\r\n        {\" \"}\r\n        <MathComponent text={labels[3]} renderNewLines={true} />\r\n      </div>\r\n      <button\r\n        className=\"rotate-button\"\r\n        style={{ fontSize: \"1.5em\" }}\r\n        onClick={(event) => {\r\n          event.stopPropagation();\r\n          setLabels((prev) => [prev[3], ...prev.slice(0, 3)]);\r\n        }}\r\n      >\r\n        ðŸ”„\r\n      </button>\r\n    </div>\r\n  );\r\n});\r\n\r\nfunction findAdjacent(squareIndex, labelIndex, gridDimension) {\r\n  const row = Math.floor(squareIndex / gridDimension);\r\n  const col = squareIndex % gridDimension;\r\n\r\n  let adjacentRow = row;\r\n  let adjacentCol = col;\r\n  let adjacentLabelIndex;\r\n\r\n  switch (labelIndex) {\r\n    case 0: // Top\r\n      adjacentRow = row - 1;\r\n      adjacentLabelIndex = 2; // Bottom label of the square above\r\n      break;\r\n    case 1: // Right\r\n      adjacentCol = col + 1;\r\n      adjacentLabelIndex = 3; // Left label of the square on the right\r\n      break;\r\n    case 2: // Bottom\r\n      adjacentRow = row + 1;\r\n      adjacentLabelIndex = 0; // Top label of the square below\r\n      break;\r\n    case 3: // Left\r\n      adjacentCol = col - 1;\r\n      adjacentLabelIndex = 1; // Right label of the square on the left\r\n      break;\r\n    default:\r\n      return null;\r\n  }\r\n\r\n  if (\r\n    adjacentRow >= 0 &&\r\n    adjacentRow < gridDimension &&\r\n    adjacentCol >= 0 &&\r\n    adjacentCol < gridDimension\r\n  ) {\r\n    const adjacentSquareIndex = adjacentRow * gridDimension + adjacentCol;\r\n    return { squareIndex: adjacentSquareIndex, labelIndex: adjacentLabelIndex };\r\n  } else {\r\n    return null; // Indicates the label is facing outwards\r\n  }\r\n}\r\n\r\nfunction checkSolution(squares, originalPairs, gridDimension) {\r\n  for (let squareIndex = 0; squareIndex < squares.length; squareIndex++) {\r\n    const square = squares[squareIndex];\r\n\r\n    for (let labelIndex = 0; labelIndex < 4; labelIndex++) {\r\n      const label = square.labels[labelIndex];\r\n\r\n      // Skip empty labels\r\n      if (label === \"\") continue;\r\n\r\n      // Find the adjacent square and label index\r\n      const adjacent = findAdjacent(squareIndex, labelIndex, gridDimension);\r\n\r\n      // If there's no adjacent square (label is facing outwards), puzzle can't be correct\r\n      if (adjacent === null) return false;\r\n\r\n      // Get the label from the adjacent square\r\n      const adjacentLabel =\r\n        squares[adjacent.squareIndex].labels[adjacent.labelIndex];\r\n\r\n      // If the adjacent label is empty, puzzle can't be correct\r\n      if (adjacentLabel === \"\") return false;\r\n\r\n      // Check if the pair exists in the original pairs list\r\n      const pair = `${label}:${adjacentLabel}`;\r\n      const reversedPair = `${adjacentLabel}:${label}`;\r\n\r\n      if (\r\n        !originalPairs.includes(pair) &&\r\n        !originalPairs.includes(reversedPair)\r\n      ) {\r\n        return false;\r\n      }\r\n    }\r\n  }\r\n\r\n  // If we've made it through all the checks, the puzzle is correct\r\n  return true;\r\n}\r\n\r\nconst SquareGrid = ({ components, originalPairs, gridDimension, sqSize }) => {\r\n  const [selected, setSelected] = useState(null);\r\n  const [firstSelected, setFirstSelected] = useState(null); // First selected square for swapping\r\n  const squareRefs = useRef([]);\r\n  const [message, setMessage] = useState(null);\r\n  const [fontSize, setFontSize] = useState(1); // Default font size\r\n  const [isCorrect, setIsCorrect] = useState(false);\r\n\r\n  const increaseFontSize = () => setFontSize((prevSize) => prevSize + 0.1);\r\n  const decreaseFontSize = () =>\r\n    setFontSize((prevSize) => Math.max(0.4, prevSize - 0.1));\r\n\r\n  const handleCheckSolution = () => {\r\n    const result = checkPuzzle();\r\n    if (result) {\r\n      setIsCorrect(true);\r\n      setMessage(\"Well Done!\");\r\n    } else {\r\n      setIsCorrect(false);\r\n      setMessage(\"Not Yet!\");\r\n    }\r\n\r\n    // Clear the message after 2 seconds\r\n    setTimeout(() => setMessage(null), 2000);\r\n  };\r\n\r\n  const checkPuzzle = () => {\r\n    const allSquares = squareRefs.current.map((ref) => ({\r\n      labels: ref.getLabels(),\r\n    }));\r\n    return checkSolution(allSquares, originalPairs, gridDimension);\r\n  };\r\n\r\n  const handleSelect = (index) => {\r\n    if (firstSelected !== null) {\r\n      // Swap labels between firstSelected and currently selected square\r\n      const firstLabels = squareRefs.current[firstSelected].getLabels();\r\n      const secondLabels = squareRefs.current[index].getLabels();\r\n      squareRefs.current[firstSelected].setLabels(secondLabels);\r\n      squareRefs.current[index].setLabels(firstLabels);\r\n\r\n      // Reset firstSelected and selected\r\n      setFirstSelected(null);\r\n      setSelected(null);\r\n\r\n      checkPuzzle();\r\n    } else {\r\n      setFirstSelected(index);\r\n      setSelected(index);\r\n    }\r\n  };\r\n\r\n  return (\r\n    <>\r\n      <div\r\n        style={{ fontSize: `${fontSize}em` }}\r\n        className={`grid-container ${\r\n          gridDimension === 3 ? \"three-by-three\" : \"four-by-four\"\r\n        }`}\r\n      >\r\n        {components.map((props, index) => (\r\n          <div key={index} className=\"grid-item\">\r\n            <SquareComponent\r\n              ref={(el) => (squareRefs.current[index] = el)}\r\n              {...props}\r\n              isSelected={selected === index}\r\n              onSelect={() => handleSelect(index)}\r\n              checkPuzzle={checkPuzzle}\r\n              sqSize={sqSize}\r\n            />\r\n          </div>\r\n        ))}\r\n      </div>\r\n      {message && (\r\n        <div className={`message ${isCorrect ? \"isCorrect\" : \"isIncorrect\"}`}>\r\n          {message}\r\n        </div>\r\n      )}\r\n      <span>\r\n        <button onClick={handleCheckSolution}>Check Solution</button>\r\n        <button onClick={increaseFontSize}>+</button>\r\n        <button onClick={decreaseFontSize}>-</button>\r\n      </span>\r\n      {isCorrect && <div className=\"celebration\">ðŸŽ‰</div>}\r\n    </>\r\n  );\r\n};\r\n\r\nconst GameArea = ({ text }) => {\r\n  const gameAreaRef = useRef(null); // Step 2: Setup ref for the game area\r\n  const [sqSize, setSqSize] = useState(250); // Default size, will update dynamically\r\n\r\n  let lines = text.split(\"\\n\");\r\n  const originalPairs = lines.map((line) => line.replace(\"\\n\", \"\"));\r\n  // Shuffle and swap function\r\n  function shuffleArray(array) {\r\n    for (let i = array.length - 1; i > 0; i--) {\r\n      const j = Math.floor(Math.random() * (i + 1));\r\n      [array[i], array[j]] = [array[j], array[i]];\r\n    }\r\n    return array;\r\n  }\r\n\r\n  // Function to rotate labels in a grid object\r\n  const rotateLabels = (gridObj) => {\r\n    const keys = [\"lb1\", \"lb2\", \"lb3\", \"lb4\"];\r\n    const numRotations = Math.floor(Math.random() * 4); // Random number between 0 and 3\r\n\r\n    for (let i = 0; i < numRotations; i++) {\r\n      const temp = gridObj[keys[3]];\r\n      for (let j = 3; j > 0; j--) {\r\n        gridObj[keys[j]] = gridObj[keys[j - 1]];\r\n      }\r\n      gridObj[keys[0]] = temp;\r\n    }\r\n\r\n    return gridObj;\r\n  };\r\n\r\n  // Randomly swap questions and answers and shuffle the order\r\n  lines = shuffleArray(\r\n    lines.map((line) => {\r\n      const [q, a] = line.split(\":\");\r\n      return Math.random() > 0.5 ? `${a}:${q}` : line;\r\n    })\r\n  );\r\n\r\n  // BUILD PUZZLE: Step 1: Determine Grid Dimension\r\n  const pairsCount = lines.length;\r\n  let gridDimension;\r\n\r\n  if (pairsCount <= 12) {\r\n    gridDimension = 3;\r\n  } else if (pairsCount <= 24) {\r\n    gridDimension = 4;\r\n  } else {\r\n    console.error(\"Too many question-answer pairs!\");\r\n  }\r\n\r\n  // Step 2: Initialize 2D Grid\r\n  const grid = Array.from({ length: gridDimension }, () =>\r\n    Array.from({ length: gridDimension }, () => ({\r\n      lb1: \"\",\r\n      lb2: \"\",\r\n      lb3: \"\",\r\n      lb4: \"\",\r\n    }))\r\n  );\r\n\r\n  // Step 3: Populate Labels\r\n  let counter = 0;\r\n  const qaPairs = lines.map((line) => {\r\n    const [question, answer] = line.split(\":\");\r\n    return { question, answer };\r\n  });\r\n\r\n  for (let row = 0; row < gridDimension; row++) {\r\n    for (let col = 0; col < gridDimension - 1; col++) {\r\n      if (counter < pairsCount) {\r\n        grid[row][col].lb2 = qaPairs[counter].question;\r\n        grid[row][col + 1].lb4 = qaPairs[counter].answer;\r\n        counter++;\r\n      }\r\n    }\r\n    if (row < gridDimension - 1) {\r\n      for (let col = 0; col < gridDimension; col++) {\r\n        if (counter < pairsCount) {\r\n          grid[row][col].lb3 = qaPairs[counter].question;\r\n          grid[row + 1][col].lb1 = qaPairs[counter].answer;\r\n          counter++;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // Step 4: Flatten 2D Grid\r\n  const components = shuffleArray(grid.flat());\r\n\r\n  // Step 5: apply a random number of rotations to each:\r\n  const rotatedComponents = components.map(rotateLabels);\r\n\r\n  useEffect(() => {\r\n    const calculateSquareSize = () => {\r\n      if (gameAreaRef.current) {\r\n        const gameAreaHeight = gameAreaRef.current.clientHeight; // Get current height of the game area\r\n        const spaceForButtons = 70; // Adjust based on your actual space for buttons, in pixels\r\n        const gridSize = gridDimension; // This comes from your existing logic\r\n        const size = (gameAreaHeight - spaceForButtons) / gridSize;\r\n        setSqSize(size); // Update state with the calculated size\r\n      }\r\n    };\r\n\r\n    calculateSquareSize(); // Calculate initially\r\n\r\n    window.addEventListener(\"resize\", calculateSquareSize); // Recalculate on resize\r\n    return () => window.removeEventListener(\"resize\", calculateSquareSize); // Cleanup listener\r\n  }, [gridDimension]); // Effect dependencies\r\n\r\n  // Pass 'components' to SquareGrid\r\n\r\n  return (\r\n    <div className=\"gameArea\" ref={gameAreaRef}>\r\n      <SquareGrid\r\n        components={rotatedComponents}\r\n        originalPairs={originalPairs}\r\n        gridDimension={gridDimension}\r\n        sqSize={sqSize}\r\n      />\r\n    </div>\r\n  );\r\n};\r\n\r\nfunction Tarsia({ text }) {\r\n  return (\r\n    <>\r\n      <GameArea text={text} />\r\n    </>\r\n  );\r\n}\r\n\r\nexport default Tarsia;\r\n"],"names":["parseAndRenderMath","text","segments","split","elements","forEach","segment","index","push","_jsx","InlineMath","math","concat","children","_ref","renderNewLines","replace","renderWithNewLines","style","whiteSpace","includes","marginTop","SquareComponent","forwardRef","props","ref","lb1","lb2","lb3","lb4","isSelected","onSelect","sqSize","labels","setLabels","useState","useImperativeHandle","getLabels","newLabels","rotateLabels","prevLabels","slice","_jsxs","width","height","className","onClick","MathComponent","fontSize","event","stopPropagation","prev","findAdjacent","squareIndex","labelIndex","gridDimension","row","Math","floor","col","adjacentLabelIndex","adjacentRow","adjacentCol","SquareGrid","components","originalPairs","selected","setSelected","firstSelected","setFirstSelected","squareRefs","useRef","message","setMessage","setFontSize","isCorrect","setIsCorrect","checkPuzzle","squares","length","square","label","adjacent","adjacentLabel","pair","reversedPair","checkSolution","current","map","_Fragment","el","firstLabels","secondLabels","handleSelect","handleCheckSolution","setTimeout","increaseFontSize","prevSize","decreaseFontSize","max","GameArea","_ref2","gameAreaRef","setSqSize","lines","line","shuffleArray","array","i","j","random","q","a","pairsCount","console","error","grid","Array","from","counter","qaPairs","question","answer","rotatedComponents","flat","gridObj","keys","numRotations","temp","useEffect","calculateSquareSize","gameAreaHeight","clientHeight","window","addEventListener","removeEventListener","_ref3"],"sourceRoot":""}