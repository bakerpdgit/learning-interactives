{"version":3,"file":"static/js/2334.35ff2a1c.chunk.js","mappings":"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","sources":["webpack://class-interactives/./src/components/AudioWordComplete.module.css?405c","components/AudioWordComplete.js"],"sourcesContent":["// extracted by mini-css-extract-plugin\nexport default {\"audioWordCompleteContainer\":\"AudioWordComplete_audioWordCompleteContainer__lxOd9\",\"audioPlayer\":\"AudioWordComplete_audioPlayer__Xs7K+\",\"sentence\":\"AudioWordComplete_sentence__T9oNz\",\"inputBox\":\"AudioWordComplete_inputBox__Y+bp7\",\"foundWord\":\"AudioWordComplete_foundWord__3yHiO\",\"wrong\":\"AudioWordComplete_wrong__oe2oB\",\"nextQuestion\":\"AudioWordComplete_nextQuestion__xPfx3\",\"celebration\":\"AudioWordComplete_celebration__Q5sEk\",\"pop\":\"AudioWordComplete_pop__0s+h5\",\"fadeOut\":\"AudioWordComplete_fadeOut__alt3w\",\"hide\":\"AudioWordComplete_hide__iYAZD\"};","import React, { useState, useEffect, useRef } from \"react\";\nimport ReactPlayer from \"react-player\"; // Included the missing import\nimport styles from \"./AudioWordComplete.module.css\";\nimport { useEditContext } from \"../EditContext\";\n\nfunction AudioWordComplete({ text }) {\n  const [blocks, setBlocks] = useState([]);\n  const [currentBlockIndex, setCurrentBlockIndex] = useState(0);\n  const [celebrate, setCelebrate] = useState(false);\n  const [currentSentence, setCurrentSentence] = useState(\"\");\n  const [currentBlock, setCurrentBlock] = useState(null);\n  const [asteriskedWords, setAsteriskedWords] = useState([]);\n  const [userInputs, setUserInputs] = useState({});\n  const [allCorrect, setAllCorrect] = useState(false);\n  const [playing, setPlaying] = useState(false);\n\n  const playerRef = useRef(null);\n  const audioRef = useRef(null); // Reference to the audio element\n  const inputRefs = useRef({});\n  const { imageData } = useEditContext(); // Access the local audio data\n\n  useEffect(() => {\n    const parseBlocks = () => {\n      const rawBlocks = text.trim().split(/\\r?\\n\\s*\\r?\\n/);\n      const parsedBlocks = rawBlocks\n        .map((block, index) => {\n          const lines = block.split(/\\r?\\n/).map((line) => line.trim());\n          if (lines.length !== 4) {\n            console.error(\n              `Block ${index + 1}: Expected 4 lines but got ${lines.length}.`\n            );\n            return null;\n          }\n          const [url, startTime, endTime, sentence] = lines;\n          return {\n            url,\n            startTime: parseFloat(startTime),\n            endTime: parseFloat(endTime),\n            sentence,\n          };\n        })\n        .filter((block) => block !== null);\n      setBlocks(parsedBlocks);\n    };\n    parseBlocks();\n  }, [text]);\n\n  useEffect(() => {\n    if (blocks.length > 0 && currentBlockIndex < blocks.length) {\n      const block = blocks[currentBlockIndex];\n      setCurrentBlock(block);\n      setCurrentSentence(block.sentence);\n\n      // Extract asterisked words\n      const regex = /\\*([^\\s]+)/g;\n      const words = [];\n      let match;\n      while ((match = regex.exec(block.sentence)) !== null) {\n        let word = match[1];\n        // Remove any trailing punctuation marks\n        word = word.replace(/[.,?!]+$/, \"\");\n        words.push(word);\n      }\n      setAsteriskedWords(words);\n\n      // Initialize user inputs\n      const inputs = {};\n      words.forEach((word) => {\n        inputs[word] = \"\";\n      });\n      setUserInputs(inputs);\n      setAllCorrect(false);\n      setPlaying(true); // Start playing immediately\n    } else if (currentBlockIndex >= blocks.length && blocks.length > 0) {\n      setCelebrate(true);\n    }\n  }, [blocks, currentBlockIndex]);\n\n  // Start or stop playback when currentBlock or playing state changes\n  useEffect(() => {\n    if (currentBlock) {\n      if (playing) {\n        if (currentBlock.url === \"[local]\") {\n          if (audioRef.current) {\n            audioRef.current.currentTime = currentBlock.startTime;\n            audioRef.current.play().catch((error) => {\n              console.error(\"Error playing audio:\", error);\n            });\n          }\n        } else {\n          if (playerRef.current) {\n            playerRef.current.seekTo(currentBlock.startTime, \"seconds\");\n          }\n        }\n      } else {\n        if (currentBlock.url === \"[local]\") {\n          if (audioRef.current) {\n            audioRef.current.pause();\n          }\n        } else {\n          // For YouTube, ReactPlayer handles pausing\n        }\n      }\n    }\n  }, [currentBlock, playing]);\n\n  useEffect(() => {\n    const allCorrect = asteriskedWords.every(\n      (w) => userInputs[w].trim().toLowerCase() === w.toLowerCase()\n    );\n    setAllCorrect(allCorrect);\n\n    // Focus on the first incomplete input\n    if (!allCorrect) {\n      const nextWord = asteriskedWords.find(\n        (word) => userInputs[word].trim().toLowerCase() !== word.toLowerCase()\n      );\n      if (nextWord && inputRefs.current[nextWord]) {\n        inputRefs.current[nextWord].focus();\n      }\n    }\n  }, [userInputs, asteriskedWords]);\n\n  const handleInputChange = (e) => {\n    const word = e.target.dataset.word;\n    const value = e.target.value;\n    setUserInputs((prevInputs) => ({\n      ...prevInputs,\n      [word]: value,\n    }));\n  };\n\n  const handleKeyDown = (e) => {\n    if (e.key === \"Enter\") {\n      const word = e.target.dataset.word;\n      const inputValue = userInputs[word];\n      if (inputValue.trim().toLowerCase() === word.toLowerCase()) {\n        // Correct\n        setUserInputs((prevInputs) => ({\n          ...prevInputs,\n          [word]: inputValue,\n        }));\n      } else {\n        // Incorrect, flash red\n        e.target.classList.add(styles.wrong);\n        setTimeout(() => {\n          e.target.classList.remove(styles.wrong);\n        }, 500);\n      }\n    }\n  };\n\n  const handlePlayAudio = () => {\n    setPlaying(false); // Stop any current playback\n    setTimeout(() => {\n      setPlaying(true); // Start playback\n    }, 100); // Slight delay to ensure state updates\n  };\n\n  const handleAudioTimeUpdate = () => {\n    if (audioRef.current) {\n      const currentTime = audioRef.current.currentTime;\n      if (currentTime >= currentBlock.endTime) {\n        audioRef.current.pause();\n        setPlaying(false);\n      }\n    }\n  };\n\n  const handleAudioEnded = () => {\n    setPlaying(false);\n  };\n\n  const handleProgress = (state) => {\n    const currentTime = state.playedSeconds;\n    if (currentTime >= currentBlock.endTime) {\n      setPlaying(false);\n    }\n  };\n\n  const nextQuestion = () => {\n    setCurrentBlockIndex((prevIndex) => prevIndex + 1);\n    setPlaying(true); // Start playback for the next question\n  };\n\n  const getSentenceElements = () => {\n    inputRefs.current = {}; // Reset input refs here\n\n    const elements = [];\n    let tempSentence = currentSentence;\n    // Remove asterisks for display\n    tempSentence = tempSentence.replace(/\\*/g, \"\");\n\n    const tokens = tempSentence.split(/(\\s+)/); // Split by spaces, keeping them\n    tokens.forEach((token, index) => {\n      const trimmedToken = token.trim();\n      // Extract trailing punctuation\n      const wordMatch = trimmedToken.match(/^([^\\s.,?!]+)([.,?!]*)$/);\n      if (wordMatch) {\n        // eslint-disable-next-line\n        const [_, wordWithoutPunct, punctuation] = wordMatch;\n\n        if (asteriskedWords.includes(wordWithoutPunct)) {\n          const inputValue = userInputs[wordWithoutPunct] || \"\";\n          const isCorrect =\n            inputValue.trim().toLowerCase() === wordWithoutPunct.toLowerCase();\n          if (isCorrect) {\n            elements.push(\n              <span\n                key={index}\n                className={styles.foundWord}\n                style={{ minWidth: `${wordWithoutPunct.length}ch` }}\n              >\n                {wordWithoutPunct}\n              </span>\n            );\n          } else {\n            elements.push(\n              <input\n                key={index}\n                ref={(el) => {\n                  if (el) {\n                    inputRefs.current[wordWithoutPunct] = el;\n                  }\n                }}\n                type=\"text\"\n                data-word={wordWithoutPunct}\n                value={inputValue}\n                onChange={handleInputChange}\n                onKeyDown={handleKeyDown}\n                style={{ width: `${wordWithoutPunct.length}ch` }}\n                className={styles.inputBox}\n              />\n            );\n          }\n          // Add the punctuation back\n          elements.push(punctuation);\n        } else {\n          elements.push(token);\n        }\n      } else {\n        elements.push(token);\n      }\n    });\n    return elements;\n  };\n\n  if (celebrate) {\n    return (\n      <div className={styles.celebration}>\n        <span role=\"img\" aria-label=\"celebrate\">\n          🎉\n        </span>\n      </div>\n    );\n  }\n\n  if (!currentBlock) {\n    return null;\n  }\n\n  return (\n    <div className={styles.audioWordCompleteContainer}>\n      <div className={styles.audioPlayer}>\n        <button onClick={handlePlayAudio}>Repeat Audio</button>\n      </div>\n\n      {currentBlock.url === \"[local]\" ? (\n        <audio\n          ref={audioRef}\n          src={imageData ? URL.createObjectURL(imageData) : \"\"}\n          onTimeUpdate={handleAudioTimeUpdate}\n          onEnded={handleAudioEnded}\n          style={{ display: \"none\" }}\n        />\n      ) : (\n        <ReactPlayer\n          ref={playerRef}\n          url={currentBlock.url}\n          playing={playing}\n          controls={false}\n          width=\"0\"\n          height=\"0\"\n          onProgress={handleProgress}\n          onEnded={() => setPlaying(false)}\n          config={{\n            youtube: {\n              playerVars: {\n                autoplay: 1,\n                controls: 0,\n                start: currentBlock.startTime,\n                end: currentBlock.endTime,\n              },\n            },\n          }}\n        />\n      )}\n\n      <div className={styles.sentence}>{getSentenceElements()}</div>\n      {allCorrect && (\n        <div className={styles.nextQuestion}>\n          <button onClick={nextQuestion}>Next Question</button>\n        </div>\n      )}\n    </div>\n  );\n}\n\nexport default AudioWordComplete;\n"],"names":["_ref","text","blocks","setBlocks","useState","currentBlockIndex","setCurrentBlockIndex","celebrate","setCelebrate","currentSentence","setCurrentSentence","currentBlock","setCurrentBlock","asteriskedWords","setAsteriskedWords","userInputs","setUserInputs","allCorrect","setAllCorrect","playing","setPlaying","playerRef","useRef","audioRef","inputRefs","imageData","useEditContext","useEffect","parseBlocks","parsedBlocks","trim","split","map","block","index","lines","line","length","console","error","concat","url","startTime","endTime","sentence","parseFloat","filter","regex","words","match","exec","word","replace","push","inputs","forEach","current","currentTime","play","catch","seekTo","pause","every","w","toLowerCase","nextWord","find","focus","handleInputChange","e","target","dataset","value","prevInputs","handleKeyDown","key","inputValue","classList","add","styles","setTimeout","remove","_jsx","className","children","role","_jsxs","onClick","handlePlayAudio","ref","src","URL","createObjectURL","onTimeUpdate","handleAudioTimeUpdate","onEnded","handleAudioEnded","style","display","ReactPlayer","controls","width","height","onProgress","state","playedSeconds","config","youtube","playerVars","autoplay","start","end","getSentenceElements","elements","tempSentence","token","wordMatch","_","wordWithoutPunct","punctuation","includes","minWidth","el","type","onChange","onKeyDown","nextQuestion","prevIndex"],"sourceRoot":""}