{"version":3,"file":"static/js/150.4eb2cbc4.chunk.js","mappings":"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","sources":["webpack://my-react-app/./src/components/Geometry.module.css?9b74","components/Geometry.js"],"sourcesContent":["// extracted by mini-css-extract-plugin\nexport default {\"GameArea\":\"Geometry_GameArea__lLLvX\",\"interactiveTitle\":\"Geometry_interactiveTitle__vbKDU\",\"instructions\":\"Geometry_instructions__FM4Mw\"};","import React, { useState, useEffect, useCallback } from \"react\";\nimport { Stage, Layer, Line, Circle, Rect, Text } from \"react-konva\";\nimport styles from \"./Geometry.module.css\"; // Ensure this path matches your CSS module file\n\nfunction Geometry({ text }) {\n  const [originalPoints, setOriginalPoints] = useState([]);\n  const [scaledPoints, setScaledPoints] = useState([]);\n  const [stageSize, setStageSize] = useState({ width: 0, height: 0 });\n  const [verticesVisible, setVerticesVisible] = useState(true); // New state for vertex visibility\n  const [dragStartPos, setDragStartPos] = useState({ x: 0, y: 0 });\n  const [options, setOptions] = useState({ angles: \"no\" }); // Default option\n  const [shapeTypes, setShapeTypes] = useState([]); // 0 for polygon, 1 for circle\n\n  // Modify this function to capture the starting drag position\n  const handlePolygonDragStart = (e) => {\n    setVerticesVisible(false); // Hide vertices\n    setDragStartPos({ x: e.target.x(), y: e.target.y() }); // Capture start position\n  };\n\n  // Function to handle vertex removal\n  const handleVertexDoubleClick = (polygonIndex, pointIndex) => {\n    setOriginalPoints((prev) => {\n      // Clone to avoid direct state mutation\n      const newPoints = [...prev];\n\n      // Ensure polygon has more than 3 vertices before removing one\n      if (newPoints[polygonIndex].length >= 1) {\n        newPoints[polygonIndex] = [\n          ...newPoints[polygonIndex].slice(0, pointIndex),\n          ...newPoints[polygonIndex].slice(pointIndex + 1),\n        ];\n\n        scalePointsToFitStage(newPoints);\n      }\n\n      return newPoints;\n    });\n  };\n\n  const handlePolygonDragEnd = (e, polygonIndex) => {\n    // Calculate the displacement in scaled coordinates\n    const scale = stageSize.width / 1000;\n    const displacement = {\n      x: (e.target.x() - dragStartPos.x) / scale,\n      y: (e.target.y() - dragStartPos.y) / scale,\n    };\n\n    // Apply the displacement to the original points\n    const updatedOriginalPoints = originalPoints.map((polygon, idx) =>\n      idx === polygonIndex\n        ? polygon.map((point) => ({\n            x: point.x + displacement.x,\n            y: point.y + displacement.y,\n          }))\n        : polygon\n    );\n\n    setOriginalPoints(updatedOriginalPoints);\n\n    // Recalculate scaled points from updated original points\n    scalePointsToFitStage(updatedOriginalPoints);\n\n    setVerticesVisible(true); // Make vertices visible again\n\n    // Reset the position of the dragged shape to negate Konva's internal drag positioning\n    e.target.position({\n      x: dragStartPos.x,\n      y: dragStartPos.y,\n    });\n    e.target.getLayer().batchDraw(); // Optimize rendering\n  };\n\n  const scalePointsToFitStage = useCallback(\n    (points) => {\n      const scale = stageSize.width / 1000; // Assuming the original size is 1000x1000\n      const scaled = points.map((polygon) =>\n        polygon.map((point) => ({\n          x: point.x * scale,\n          y: point.y * scale,\n        }))\n      );\n      setScaledPoints(scaled);\n    },\n    [stageSize.width, setScaledPoints]\n  );\n\n  useEffect(() => {\n    scalePointsToFitStage(originalPoints);\n  }, [stageSize, originalPoints, scalePointsToFitStage]);\n\n  function parseShapes(text) {\n    const lines = text.split(\"\\n\");\n    let options = { angles: \"no\" }; // Default option\n    let shapes = []; // Stores both polygons and circles as arrays of points\n    let shapeTypes = []; // 0 for polygon, 1 for circle\n\n    lines.forEach((line) => {\n      if (line.startsWith(\"OPTIONS:\")) {\n        // Parse options as before\n        line\n          .substring(\"OPTIONS:\".length)\n          .split(\",\")\n          .forEach((option) => {\n            const [key, value] = option.split(\"=\");\n            options[key] = value;\n          });\n      } else if (line.includes(\"[\")) {\n        // Circle\n        const cpoints = line\n          .match(/\\[(.*?)\\]/g)\n          .map((point) => point.replace(/\\[|\\]/g, \"\").split(\",\").map(Number));\n        shapes.push([\n          { x: cpoints[0][0], y: cpoints[0][1] },\n          { x: cpoints[1][0], y: cpoints[1][1] },\n        ]); // Store as two points\n        shapeTypes.push(1); // Mark as circle\n      } else {\n        // Polygon\n        const ppoints = line.match(/\\((.*?)\\)/g)?.map((ppoint) => {\n          const [x, y] = ppoint.replace(/\\(|\\)/g, \"\").split(\",\").map(Number);\n          return { x, y };\n        });\n        if (ppoints) {\n          shapes.push(ppoints); // Store polygon points normally\n          shapeTypes.push(0); // Mark as polygon\n        }\n      }\n    });\n\n    return { options, points: shapes, shapeTypes };\n  }\n\n  useEffect(() => {\n    const { options: parsedOptions, points, shapeTypes } = parseShapes(text);\n    setOptions(parsedOptions);\n    setOriginalPoints(points);\n    setShapeTypes(shapeTypes);\n    updateStageSize(); // This triggers scaling of points\n    window.addEventListener(\"resize\", updateStageSize);\n    return () => window.removeEventListener(\"resize\", updateStageSize);\n  }, [text]);\n\n  function updateStageSize() {\n    const size = Math.min(window.innerWidth * 0.9, window.innerHeight * 0.9);\n    setStageSize({ width: size, height: size });\n  }\n\n  // Example handler for right-click events on shapes\n  const handleShapeRightClick = (event, shapeIndex) => {\n    event.evt.preventDefault(); // Prevent default context menu\n\n    setOriginalPoints((prevShapes) => {\n      // Access the shape directly using shapeIndex\n      const shapeToDuplicate = prevShapes[shapeIndex];\n      if (!Array.isArray(shapeToDuplicate)) {\n        console.error(\"Expected an array of points, got:\", shapeToDuplicate);\n        return prevShapes; // Return unchanged if unexpected structure\n      }\n\n      // Clone and offset the shape\n      const newShape = shapeToDuplicate.map((point) => ({\n        x: point.x + 20, // Apply offset\n        y: point.y + 20,\n      }));\n\n      // Return new array with the duplicated shape added\n      return [...prevShapes, newShape];\n    });\n\n    // Remember to also update shapeTypes state if necessary\n    setShapeTypes((prevTypes) => [...prevTypes, prevTypes[shapeIndex]]);\n  };\n\n  // Utility function to calculate distance from a point to a line segment\n  function distanceFromPointToLineSegment(px, py, x1, y1, x2, y2) {\n    let lineLength = Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);\n    if (lineLength === 0) return Math.sqrt((px - x1) ** 2 + (py - y1) ** 2);\n    let t = ((px - x1) * (x2 - x1) + (py - y1) * (y2 - y1)) / lineLength ** 2;\n    t = Math.max(0, Math.min(1, t));\n    let lx = x1 + t * (x2 - x1);\n    let ly = y1 + t * (y2 - y1);\n    return Math.sqrt((px - lx) ** 2 + (py - ly) ** 2);\n  }\n\n  const handleLineDoubleClick = (e, polygonIndex) => {\n    const stage = e.target.getStage();\n    const pointerPosition = stage.getPointerPosition();\n    const scale = stageSize.width / 1000;\n    const clickX = pointerPosition.x / scale;\n    const clickY = pointerPosition.y / scale;\n\n    const polygon = originalPoints[polygonIndex];\n    let closestSegmentIndex = 0;\n    let minDistance = Infinity;\n\n    for (let i = 0; i < polygon.length; i++) {\n      const nextIndex = (i + 1) % polygon.length;\n      const distance = distanceFromPointToLineSegment(\n        clickX,\n        clickY,\n        polygon[i].x,\n        polygon[i].y,\n        polygon[nextIndex].x,\n        polygon[nextIndex].y\n      );\n\n      if (distance < minDistance) {\n        minDistance = distance;\n        closestSegmentIndex = i;\n      }\n    }\n\n    // Insert the new point after the closest segment's start point\n    const newPoint = { x: clickX, y: clickY };\n    const updatedPolygon = [\n      ...polygon.slice(0, closestSegmentIndex + 1),\n      newPoint,\n      ...polygon.slice(closestSegmentIndex + 1),\n    ];\n\n    const updatedOriginalPoints = [\n      ...originalPoints.slice(0, polygonIndex),\n      updatedPolygon,\n      ...originalPoints.slice(polygonIndex + 1),\n    ];\n\n    setOriginalPoints(updatedOriginalPoints);\n    scalePointsToFitStage(updatedOriginalPoints);\n  };\n\n  const handleDragEnd = (e, polygonIndex, pointIndex) => {\n    const lastKnownGoodPosition = scaledPoints[polygonIndex][pointIndex];\n    e.target.position({\n      x: lastKnownGoodPosition.x,\n      y: lastKnownGoodPosition.y,\n    });\n    // Force a re-render to ensure the circle's position is updated visually\n    // This is typically not necessary as the position change is immediate,\n    // but is here if additional state updates or side effects are needed.\n  };\n\n  const handleDragMove = (e, polygonIndex, pointIndex) => {\n    const scale = stageSize.width / 1000;\n    // Calculate proposed new positions before applying them\n    const proposedNewX = e.target.x() / scale;\n    const proposedNewY = e.target.y() / scale;\n\n    // Check if the proposed new positions fall outside the 1000x1000 area\n    if (\n      proposedNewX < 20 ||\n      proposedNewX > 980 ||\n      proposedNewY < 0 ||\n      proposedNewY > 980\n    ) {\n      // If outside the bounds, reject the update and return to leave the point as is\n      return;\n    }\n\n    // If within bounds, proceed to update the points\n    const newScaledPoints = scaledPoints.map((polygon, pIdx) => {\n      if (pIdx === polygonIndex) {\n        return polygon.map((point, ptIdx) => {\n          if (ptIdx === pointIndex) {\n            return { x: e.target.x(), y: e.target.y() };\n          }\n          return point;\n        });\n      }\n      return polygon;\n    });\n    setScaledPoints(newScaledPoints);\n\n    // Update original points to reflect the change for future resizes\n    const newOriginalPoints = newScaledPoints.map((polygon) =>\n      polygon.map((point) => ({\n        x: (point.x * 1000) / stageSize.width,\n        y: (point.y * 1000) / stageSize.height,\n      }))\n    );\n    setOriginalPoints(newOriginalPoints);\n  };\n\n  function vectorMagnitude(v) {\n    return Math.sqrt(v.x * v.x + v.y * v.y);\n  }\n\n  // Utility function to calculate the dot product of two vectors\n  function dotProduct(u, v) {\n    return u.x * v.x + u.y * v.y;\n  }\n\n  // Function to calculate the angle at a vertex given three points: prev, curr, and next\n  function calculateAngle(prev, curr, next) {\n    const u = { x: prev.x - curr.x, y: prev.y - curr.y };\n    const v = { x: next.x - curr.x, y: next.y - curr.y };\n\n    const dot = dotProduct(u, v);\n    const magU = vectorMagnitude(u);\n    const magV = vectorMagnitude(v);\n    const cosTheta = dot / (magU * magV);\n\n    // Convert to degrees for readability\n    return Math.acos(cosTheta) * (180 / Math.PI);\n  }\n\n  return (\n    <>\n      <div>\n        <p className={styles.instructions}>\n          Right click a shape to duplicate; double-click a point to remove;\n          double-click a polygon to add a vertex; drag a shape to move it.\n        </p>\n      </div>\n      <div className={styles.GameArea}>\n        <Stage\n          width={stageSize.width}\n          height={stageSize.height}\n          className={styles.GameArea}\n        >\n          <Layer>\n            {/* Draw a rectangle that matches the size of the Stage to act as a border */}\n            <Rect\n              x={0}\n              y={0}\n              width={stageSize.width}\n              height={stageSize.height}\n              stroke=\"black\" // Color of the border\n              strokeWidth={4} // Thickness of the border\n            />\n            {scaledPoints.map((polygon, polygonIndex) => (\n              <React.Fragment key={polygonIndex}>\n                {shapeTypes[polygonIndex] === 0 && (\n                  // Render polygon logic\n                  <Line\n                    points={polygon.flatMap((p) => [p.x, p.y])}\n                    closed={true}\n                    stroke=\"black\"\n                    onDblClick={(e) => handleLineDoubleClick(e, polygonIndex)}\n                    onContextMenu={(e) =>\n                      handleShapeRightClick(e, polygonIndex)\n                    }\n                    draggable\n                    onDragStart={handlePolygonDragStart}\n                    onDragEnd={(e) => handlePolygonDragEnd(e, polygonIndex)}\n                  />\n                )}\n                {shapeTypes[polygonIndex] === 1 && (\n                  // Render circle\n                  <Circle\n                    x={polygon[0].x} // Center x\n                    y={polygon[0].y} // Center y\n                    radius={Math.sqrt(\n                      Math.pow(polygon[1].x - polygon[0].x, 2) +\n                        Math.pow(polygon[1].y - polygon[0].y, 2)\n                    )}\n                    stroke=\"black\"\n                    strokeWidth={2}\n                    onContextMenu={(e) =>\n                      handleShapeRightClick(e, polygonIndex)\n                    }\n                    draggable\n                    onDragStart={handlePolygonDragStart}\n                    onDragEnd={(e) => handlePolygonDragEnd(e, polygonIndex)}\n                  />\n                )}\n                {polygon.map((point, pointIndex) => (\n                  <Circle\n                    key={pointIndex}\n                    x={point.x}\n                    y={point.y}\n                    radius={5}\n                    fill=\"red\"\n                    draggable={verticesVisible}\n                    visible={verticesVisible}\n                    onDragMove={(e) =>\n                      handleDragMove(e, polygonIndex, pointIndex)\n                    }\n                    onDragEnd={(e) =>\n                      handleDragEnd(e, polygonIndex, pointIndex)\n                    }\n                    onDblClick={() =>\n                      handleVertexDoubleClick(polygonIndex, pointIndex)\n                    }\n                  />\n                ))}\n                {polygon.length > 2 &&\n                  options.angles === \"yes\" &&\n                  polygon.map((point, pointIndex) => {\n                    const prev =\n                      polygon[\n                        (pointIndex - 1 + polygon.length) % polygon.length\n                      ];\n                    const curr = point;\n                    const next = polygon[(pointIndex + 1) % polygon.length];\n\n                    const angle = calculateAngle(prev, curr, next);\n                    const angleText = angle.toFixed(1) + \"Â°\";\n\n                    // Implementing the bisector method for label positioning\n                    if (\n                      Math.abs(angle) > 0.5 &&\n                      Math.abs(angle - 180.0) > 0.5\n                    ) {\n                      // Normalize function to calculate unit vectors\n                      const normalize = (vector) => {\n                        const length = Math.sqrt(\n                          vector.x * vector.x + vector.y * vector.y\n                        );\n                        return { x: vector.x / length, y: vector.y / length };\n                      };\n\n                      // Calculate vectors to previous and next points\n                      const vectorToPrev = normalize({\n                        x: prev.x - curr.x,\n                        y: prev.y - curr.y,\n                      });\n                      const vectorToNext = normalize({\n                        x: next.x - curr.x,\n                        y: next.y - curr.y,\n                      });\n\n                      // Bisector direction\n                      const bisector = normalize({\n                        x: vectorToPrev.x + vectorToNext.x,\n                        y: vectorToPrev.y + vectorToNext.y,\n                      });\n\n                      let nudgeDistance = stageSize.width / 35; // Adjust based on your requirements\n\n                      let rotationAngle =\n                        Math.atan2(bisector.y, bisector.x) * (180 / Math.PI);\n\n                      if (rotationAngle < -90 || rotationAngle > 90) {\n                        rotationAngle += 180; // Flip text upside down if it's facing left\n                        nudgeDistance *= 3;\n                      }\n\n                      return (\n                        <React.Fragment key={pointIndex}>\n                          <Text\n                            x={curr.x + bisector.x * nudgeDistance}\n                            y={curr.y + bisector.y * nudgeDistance}\n                            text={angleText}\n                            fontSize={12}\n                            fill=\"black\"\n                            visible={verticesVisible}\n                            rotation={rotationAngle}\n                          />\n                        </React.Fragment>\n                      );\n                    } else {\n                      return null;\n                    }\n                  })}\n              </React.Fragment>\n            ))}\n          </Layer>\n          <Layer>\n            {scaledPoints.map((polygon, polygonIndex) => (\n              <React.Fragment key={`v${polygonIndex}`}>\n                {polygon.map((point, pointIndex) => (\n                  <Circle\n                    key={pointIndex}\n                    x={point.x}\n                    y={point.y}\n                    radius={5}\n                    fill=\"red\"\n                    draggable={verticesVisible}\n                    visible={verticesVisible}\n                    onDragMove={(e) =>\n                      handleDragMove(e, polygonIndex, pointIndex)\n                    }\n                    onDragEnd={(e) =>\n                      handleDragEnd(e, polygonIndex, pointIndex)\n                    }\n                    onDblClick={() =>\n                      handleVertexDoubleClick(polygonIndex, pointIndex)\n                    }\n                  />\n                ))}\n              </React.Fragment>\n            ))}\n          </Layer>\n        </Stage>\n      </div>\n    </>\n  );\n}\n\nexport default Geometry;\n"],"names":["_ref","text","originalPoints","setOriginalPoints","useState","scaledPoints","setScaledPoints","stageSize","setStageSize","width","height","verticesVisible","setVerticesVisible","dragStartPos","setDragStartPos","x","y","options","setOptions","angles","shapeTypes","setShapeTypes","handlePolygonDragStart","e","target","handleVertexDoubleClick","polygonIndex","pointIndex","prev","newPoints","length","slice","scalePointsToFitStage","handlePolygonDragEnd","scale","displacement","updatedOriginalPoints","map","polygon","idx","point","position","getLayer","batchDraw","useCallback","points","scaled","updateStageSize","size","Math","min","window","innerWidth","innerHeight","useEffect","parsedOptions","lines","split","shapes","forEach","line","startsWith","substring","option","key","value","includes","cpoints","match","replace","Number","push","_line$match","ppoints","ppoint","parseShapes","addEventListener","removeEventListener","handleShapeRightClick","event","shapeIndex","evt","preventDefault","prevShapes","shapeToDuplicate","Array","isArray","console","error","newShape","prevTypes","distanceFromPointToLineSegment","px","py","x1","y1","x2","y2","lineLength","sqrt","t","max","lx","ly","handleDragEnd","lastKnownGoodPosition","handleDragMove","proposedNewX","proposedNewY","newScaledPoints","pIdx","ptIdx","newOriginalPoints","vectorMagnitude","v","_jsxs","_Fragment","children","_jsx","className","styles","Stage","Layer","Rect","stroke","strokeWidth","React","Line","flatMap","p","closed","onDblClick","handleLineDoubleClick","pointerPosition","getStage","getPointerPosition","clickX","clickY","closestSegmentIndex","minDistance","Infinity","i","nextIndex","distance","newPoint","updatedPolygon","onContextMenu","draggable","onDragStart","onDragEnd","Circle","radius","pow","fill","visible","onDragMove","curr","next","angle","u","cosTheta","dotProduct","acos","PI","calculateAngle","angleText","toFixed","abs","normalize","vector","vectorToPrev","vectorToNext","bisector","nudgeDistance","rotationAngle","atan2","Text","fontSize","rotation","concat"],"sourceRoot":""}